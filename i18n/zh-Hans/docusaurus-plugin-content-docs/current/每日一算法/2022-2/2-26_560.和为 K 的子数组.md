---
sidebar_position: 100
---

# 2-26 560.å’Œä¸º K çš„å­æ•°ç»„

> Dateï¼š2022-02-27 17:45:52

ä¸‰ä¸ªå°è¡¨æƒ…è¡¨ç¤ºé¢˜ç›®éš¾åº¦ï¼š:smile:ç®€å• :confused:ä¸­ç­‰ :worried:å›°éš¾

### [é¢˜ç›®ï¼š560.å’Œä¸º K çš„å­æ•°ç»„](https://leetcode-cn.com/problems/subarray-sum-equals-k/) (ğŸ˜•)

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„å’Œä¸€ä¸ªæ•´æ•° kï¼Œä½ éœ€è¦æ‰¾åˆ°è¯¥æ•°ç»„ä¸­å’Œä¸º k çš„è¿ç»­çš„å­æ•°ç»„çš„ä¸ªæ•°ã€‚

### è¯´æ˜

1. æ•°ç»„çš„é•¿åº¦ä¸º [1, 20,000]ã€‚
2. æ•°ç»„ä¸­å…ƒç´ çš„èŒƒå›´æ˜¯ [-1000, 1000] ï¼Œä¸”æ•´æ•° k çš„èŒƒå›´æ˜¯ [-1e7, 1e7]ã€‚

### ç¤ºä¾‹

ç¤ºä¾‹ 1

```
 è¾“å…¥: nums = [1,1,1], k = 2

 [1,1], [1,1]
 è¾“å‡º: 2
```

ç¤ºä¾‹ 2

```
 è¾“å…¥ï¼šnums = [1,2,3], k = 3

 [1,2], [3]
 è¾“å‡ºï¼š2
```

### åˆ†æ

è¯¥é¢˜è‚¯å®šä¸èƒ½ç”¨æ»‘åŠ¨çª—å£ï¼Œå› ä¸ºçª—å£æ˜¯å›ºå®šçš„ï¼Œä¸ç¬¦åˆè¯¥é¢˜

è§£æ³•æœ‰ï¼š1`æš´åŠ›æ³•` 2`å‰ç¼€å’Œ+å“ˆå¸Œè¡¨ä¼˜åŒ–`

### é¢˜è§£

1.æš´åŠ›æ³•ï¼Œè¿™é‡Œé‡‡ç”¨çš„æ­£å‘å­ä¸²æ±‚æ³•ï¼Œä¹Ÿæœ‰åå‘å­ä¸²çš„è§£æ³•ï¼Œå¤æ‚åº¦éƒ½æ˜¯ `O(n^2)`

```
 function main() {
   // const nums = [1, 1, 1]
   const nums = [1, 2, 3]
   const k = 3

   console.log('[]:', subarraySum(nums, k))
 }

 main()

 function subarraySum(nums: number[], k: number): number {
   let res = 0
   const len = nums.length

   for (let left = 0; left < len; ++left) {
     let sum = 0
     for (let right = left; right < len; ++right) {
       sum += nums[right]

       if (sum === k) {
         ++res
       }

       // can not continue, because the next element maybe 0 or negative number
       // continue
       // } else if (sum > k) {
       //   continue
       // }
     }
   }

   return res
 }
```

2.å‰ç¼€å’Œæ³•ï¼ˆå«å“ˆå¸Œä¼˜åŒ–ï¼‰

è¿™é‡Œæœ€å¥½çœ‹è§†é¢‘å›¾è§£ï¼Œhttps://leetcode-cn.com/problems/subarray-sum-equals-k/solution/he-wei-kde-zi-shu-zu-by-leetcode-solution/

ä½†è¦æ³¨æ„ï¼Œå…ˆåˆ¤æ–­æ˜¯å¦åœ¨ map ä¸­ï¼Œä¹‹åå† map.setï¼Œå› ä¸º[j...i-1]

![image-20220227095813985](https://cdn.gincool.com//img/image-20220227095813985.png)

```
 function subarraySum2(nums: number[], k: number): number {
   let count = 0
   let pre = 0
   const len = nums.length
   const map = new Map<number, number>()

   map.set(pre, 1)

   for (let i = 0; i < len; ++i) {
     pre += nums[i]

     // console.log('[map]:', map)
     // console.log('[pre]:', pre)

     // map's elment is [j...i-1]
     // so it must be ahead of map.set
     let exist0 = map.get(pre - k)
     if (exist0) {
       count += exist0
     }

     // maintain the pre map
     let exist1 = map.get(pre)
     if (exist1) {
       map.set(pre, ++exist1)
     } else {
       map.set(pre, 1)
     }
   }

   return count
 }
```

### æ‰©å±• 1ï¼šæ»‘åŠ¨çª—å£ç®—æ³•

![01_æ»‘åŠ¨çª—å£](https://cdn.gincool.com//img/01_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png)

ä¸€èˆ¬æ±‚è§£æœ€å¤§å’Œã€æ•°ç»„/å­—ç¬¦ä¸²çš„å­å…ƒç´ é—®é¢˜

ç¤ºä¾‹ï¼šç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œè®¡ç®—é•¿åº¦ä¸º **'k'** çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§æ€»å’Œã€‚

```
 è¾“å…¥: [100,200,300,400]

 è¾“å‡º: 700
```

é¢˜è§£

```
 function main() {
   const arr = [100, 200, 300, 400, 500, 100]
   const k = 2

   console.log('[]:', maxSum(arr, k))
 }

 main()

 function maxSum(arr: number[], k: number): number {
   let maxSum = 0
   const len = arr.length

   // è¾¹ç•Œæ¡ä»¶
   if (len < k) return -1

   // æ ¹æ®çª—å£å¤§å°ï¼Œåˆæ­¥è®¡ç®—æœ€å¤§å€¼
   for (let i = 0; i < k; ++i) {
     maxSum += arr[i]
   }

   // æŒªåŠ¨çª—å£ï¼Œå¹¶å°è¯•æ›´æ–°æœ€å¤§å€¼
   for (let i = k; i < len; ++i) {
     const sum = maxSum + arr[i] - arr[i - k]
     maxSum = Math.max(maxSum, sum)
   }

   return maxSum
 }
```

### æ‰©å±• 2ï¼šåŠ¨æ€è§„åˆ’ç®—æ³•

å…³äºåŠ¨æ€è§„åˆ’ï¼Œå¯ä»¥å‚è€ƒ **[1]**

[1] ä»€ä¹ˆæ˜¯åŠ¨æ€è§„åˆ’ï¼ˆDynamic Programmingï¼‰ï¼ŸåŠ¨æ€è§„åˆ’çš„æ„ä¹‰æ˜¯ä»€ä¹ˆï¼Ÿ.https://www.zhihu.com/question/23995189

è¿™é‡Œä¸Šä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ï¼Œé¢˜ç›®

ç»™å®š 1,5,11 ä¸‰ç§é¢å€¼ï¼Œè¯·ç»™å‡ºå‡‘å‡º 15 å…ƒçš„æœ€å°ç»„åˆæ–¹å¼

é¢˜è§£

```
 function main() {
   const coinFace = [1, 5, 11]
   const w = 15

   console.log('[]:', coinWaysNum(coinFace, w))
 }

 main()

 function coinWaysNum(coinFace: number[], w: number): number {
   const fn = [0]

   for (let i = 1; i <= w; ++i) {
     let cost = Infinity

     for (let j = 0; j < coinFace.length; ++j) {
       if (i - coinFace[j] >= 0) cost = Math.min(cost, fn[i - coinFace[j]] + 1)
     }

     console.log(`[cost${i}]:`, cost)
     fn[i] = cost
   }

   return fn[w]
 }
```
