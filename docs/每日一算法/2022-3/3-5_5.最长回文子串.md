---
sidebar_position: 100
---

# 3-5 5.最长回文子串

> Date：2022-03-06 20:01:10

### 题目：[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/submissions/) ( 中等:confused: )

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

### 示例

示例 1：

```ts
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

 示例 2：

```ts
输入：s = "cbbd"
输出："bb"
```

### 分析

- 暴力法：枚举所有的子串，判断是否为回文串

  耗时：枚举需要O(n^2)，判断需要O(n)，所以时间复杂度为O(n^3)

- 动态规划，边缘扩散

  - 详细见：[最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/) 

  - 动态转移方程：

    *P*(*i*,*j*)=*P*(*i*+1,*j*−1)∧(Si==Sj)

    即： 如果[i+1, j-1]为回文，且nums[i] === nums[j]，则[i, j]区间为回文，它们是相等关系

  - 下面是size(当前区间个数)和i、j变化的图

    会发现，越到后面，`[i+1, j-1]` 的回文性就已经确定了

    比如，size=5时，此时，`[i+1, j-1]` 的区间就是b和b的区间，而b和b的回文性在size=3的时候就求出来了

    ![image-20220311124025313](https://gitee.com/nahaohao/pic-upload/raw/master/img/image-20220311124025313.png)

### 题解

动态规划

```ts
function longestPalindrome(s: string): string {
  const len = s.length
  // error:
  // const dep: boolean[][] = new Array(len).fill([])
  const dep: boolean[][] = new Array(len)
  let begin = 0,
      maxLen = 1

  // the substring's length is 1, so it is a palindrome
  for (let i = 0; i < len; ++i) {
    const newArr = new Array(len)
    newArr[i] = true
    dep[i] = newArr
  }

  for (let size = 2; size <= len; ++size) {
    for (let i = 0; i < len; ++i) {
      // size is [i, j]'s length
      // size = j - i + 1 ==> j = size + i -1
      const j = size + i - 1

      if (j >= len) {
        break
      }

      if (s[i] !== s[j]) {
        dep[i][j] = false
      } else {
        if (j - i + 1 <= 3) {
          dep[i][j] = true
        } else {
          dep[i][j] = dep[i + 1][j - 1]
        }
      }

      const newMaxLen = j - i + 1
      if (dep[i][j] && newMaxLen > maxLen) {
        maxLen = newMaxLen
        begin = i
      }
    }
  }

  return s.substring(begin, begin + maxLen)
}
```

使用

```ts
function main() {
  // const s = 'babbd'
  const s = 'cbbd'

  console.log('[]:', longestPalindrome(s))
}

main()

export {}
```

### 扩展0：根据下标计算数组的长度

```ts
const len = j - i + 1

const j = len + i - 1
const i = j - len + 1
```

### 扩展1：Js中初始化二维数组？

我想初始化一个3x3的存放boolean值的二维数组，怎么操作呢？

可能会这样写：

```ts
const len = 3

const dp: boolean[][] = new Array(len).fill(new Array(len).fill(true))

// =>> 输出
// [
//   [true, true, true],
//   [true, true, true],
//   [true, true, true],
// ]
```

看起来，符合预期，我尝试修改第0行第1个元素为false

```ts
dp[0][1] = false
console.log('[dp]:', dp)

// =>> 输出
// [
//   [true, false, true],
//   [true, false, true],
//   [true, false, true],
// ]
```

嗯？为什么第2行，第3行也变了

猜测，`Array.fill` 填充的是同一个数组对象，即三个数组引用地址是一样的

**正确写法**

```ts
const len = 3
const dp: boolean[][] = new Array(len)

for (let i = 0; i < len; ++i) {
  dp[i] = new Array(len).fill(true)
}
```

输出

```ts
[
  [true, true, true],
  [true, true, true],
  [true, true, true],
]
```

