---
title: 010.拖拽元素
categories:
  - 大前端
tags:
  - css
  - 拖拽
  - 动态模板
---

曾今有一次面试，被问到如何通过拖拽自动生成相应的模板，当场懵逼，拖拽都不会，还动态生成模板

关键字：拖拽、动态模板【未实现】



首先，拖拽流程为：拖拽元素分为**拖动元素**和**放置元素**，拖动元素被拖起来之后，放到放置元素中去，这就是拖拽流程

> 拖拽的几个事件

一共有7个事件，拖动有3个，放置有4个

拖动：dragstart、drag、dragend，也就是开始、拖过程、拖动结束三个事件

放置：dragenter、dragover、dragleave和drop，也就是被拖动元素碰到放置元素、从放置元素经过、从放置元素离开、最终鼠标放开留在放置元素上的四个事件

> 练习1：拖拽元素

先看效果吧：

![image-20210717232434538](https://gitee.com/nahaohao/pic-upload/raw/master/img/image-20210717232434538.png)

```html
<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    * {
      margin: 0;
    }

    .box {
      display: grid;
      /* grid真得好用，推荐阮一峰的教程，MDN可以当做手册看
                http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html
                */
      width: 200px;

      grid-template-columns: 1fr 1fr;
    }

    .box1 {
      width: 100%;
      height: 100px;
      border: 1px solid green;
    }

    .box2 {
      width: 100%;
      height: 100px;
      border: 1px solid lightcoral;
    }

    .el1 {
      width: 50px;
      height: 50px;
      border: 1px solid red;
    }

    .el2 {
      width: 50px;
      height: 50px;
      border: 1px solid green;
    }
  </style>
</head>

<body>

  <div class="box">
    <div id="box1" class="box2">
    </div>
    <div id="box2" class="box2">
    </div>
  </div>

  <div id="el" class="el">
    <div id="el1" class="el1" draggable="true">1
      <!-- 注意让元素支持拖拽，默认不支持 -->
    </div>
    <div id="el2" class="el2" draggable="true">2
    </div>
  </div>


  <script>
    window.onload = function () {

      const box1 = document.getElementById('box1')
      const box2 = document.getElementById('box2')
      const el = document.getElementById('el')
      const el1 = document.getElementById('el1')
      const el2 = document.getElementById('el2')

      el1.father = el
      el2.father = el
      // 记录它们各自的父亲

      let currentDraggingElement = null
      // 记录当前被拖动的元素，因为我发现拖动事件中获取不到放入的元素，呜呜呜

      el1.addEventListener('dragstart', function (e) {
        currentDraggingElement = this
      }, false)
      el2.addEventListener('dragstart', function (e) {
        currentDraggingElement = this
      }, false)
      // 给元素设置开始拖动事件，并重置当前被拖动的元素


      // 下面就是给盒子设置一些事件
      box1.addEventListener('drop', function (e) {
        // 当元素放入的时候
        if (!currentDraggingElement) return

        currentDraggingElement.father.removeChild(currentDraggingElement)
        this.appendChild(currentDraggingElement)

        currentDraggingElement.father = this
        // 重置元素的父亲
      })
      draggable(box1)
      // 这两个事件主要去除默认事件，让盒子支持放置元素，默认不支持

      box2.addEventListener('drop', function (e) {
        if (!currentDraggingElement) return

        currentDraggingElement.father.removeChild(currentDraggingElement)
        this.appendChild(currentDraggingElement)

        currentDraggingElement.father = this
      })
      draggable(box2)

    }

    function draggable(el) {
      el.addEventListener('dragenter', function (e) {
        e.preventDefault()
      })
      el.addEventListener('dragover', function (e) {
        e.preventDefault()
      })
    }
  </script>
</body>

</html>
```

> 练习2：拖拽结合事件委托

上面练习我们可以看出有一个弊端，如果子元素过多，那么要给所以子元素设置事件，这样会产生大量内存消耗，所以这里用事件委托来优化

这样发现，只需要6个事件即可，而拖动子元素可以定义无限个

```html
<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    * {
      margin: 0;
    }

    .box {
      display: grid;
      /* grid真得好用，推荐阮一峰的教程，MDN可以当做手册看
                http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html
                */
      width: 200px;

      grid-template-columns: 1fr 1fr;
    }

    .box1 {
      width: 100%;
      height: 100px;
      border: 1px solid green;
    }

    .box2 {
      width: 100%;
      height: 100px;
      border: 1px solid lightcoral;
    }

    .el1 {
      width: 50px;
      height: 50px;
      border: 1px solid red;
    }

    .el2 {
      width: 50px;
      height: 50px;
      border: 1px solid green;
    }

    .el3 {
      width: 50px;
      height: 50px;
      border: 1px solid pink;
    }
  </style>
</head>

<body>

  <div id="box" class="box">
    <div id="box1" class="box2">
    </div>
    <div id="box2" class="box2">
    </div>
  </div>

  <div id="el" class="el">
    <div id="el1" class="el1" draggable="true">1
      <!-- 注意让元素支持拖拽，默认不支持 -->
    </div>
    <div id="el2" class="el2" draggable="true">2
    </div>
    <div id="el3" class="el3" draggable="true">3
    </div>
    <!-- 下面可以继续添加子元素 -->
  </div>


  <script>
    window.onload = function () {

      const box = document.getElementById('box')
      const box1 = document.getElementById('box1')
      const box2 = document.getElementById('box2')
      const el = document.getElementById('el')
      const el1 = document.getElementById('el1')
      const el2 = document.getElementById('el2')
      const el3 = document.getElementById('el3')
      // 遍历子元素操作比较好，但这里就不写了

      el1.father = el
      el2.father = el
      el3.father = el
      // 记录它们各自的父亲

      let currentDraggingElement = null
      // 中间量

      // 给子元素的父亲们设置拖拽委托事件【只要是子元素可能待的地方都要设置拖拽事件】
      el.addEventListener('dragstart', function (e) {
        console.log('[el委托]:', e)
        currentDraggingElement = e.target
      })

      box1.addEventListener('dragstart', function (e) {
        console.log('[box1委托]:', e)
        currentDraggingElement = e.target
      })
      box2.addEventListener('dragstart', function (e) {
        console.log('[box2委托]:', e)
        currentDraggingElement = e.target
      })

      // 给容器的父亲设置放置事件
      box.addEventListener('drop', function (e) {
        const that = e.target

        console.log('[]:', typeof (that))
        that.father && alert('[Wraning]: 子元素身上不允许放置元素!')
        if (!currentDraggingElement || that.father) return
        // 【注意】判断元素是否为el子元素，如果是，不能进行放置元素 否则会出错

        currentDraggingElement.father.removeChild(currentDraggingElement)
        that.appendChild(currentDraggingElement)

        currentDraggingElement.father = that
        // 重置元素的父亲
      })
      draggable(box)
      // 让盒子接受拖拽元素

    }

    function draggable(el) {
      el.addEventListener('dragenter', function (e) {
        // e.target.preventDefault()
        // 报错，preventDefault是事件的方法，不是元素的方法

        e.preventDefault()
        // 【注意】在委托事件中，只要父亲可以接受拖拽元素即可
      })
      el.addEventListener('dragover', function (e) {
        // e.target.preventDefault()
        e.preventDefault()
      })
    }
  </script>
</body>

</html>
```



> react中封装的拖拽

第一个：[react-draggable-list](https://github.com/StreakYC/react-draggable-list)

![image-20210717234320752](https://gitee.com/nahaohao/pic-upload/raw/master/img/image-20210717234320752.png)

第二个：[react-draggable](https://github.com/react-grid-layout/react-draggable)

![image-20210717234425122](https://gitee.com/nahaohao/pic-upload/raw/master/img/image-20210717234425122.png)

> vue的拖拽

第一个：[Vue.Draggable](https://github.com/SortableJS/Vue.Draggable)

![image-20210717234532734](https://gitee.com/nahaohao/pic-upload/raw/master/img/image-20210717234532734.png)

一些链接：

- vue封装的拖拽.https://github.com/SortableJS/Vue.Draggable
- react封装的拖拽.https://github.com/react-grid-layout/react-draggable
- CSS Grid 网格布局教程.http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html

# 