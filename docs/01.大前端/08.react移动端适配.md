---
title: 08.react移动端适配
categories:
  - 大前端
tags:
  - 案例 
  - css
  - react
---



# 移动端适配

```sh
yarn add customize-cra postcss-px-to-viewport -D
```

```sh
yarn add postcss-px-to-viewport --dev
```

```sh
yarn add react-app-rewire-postcss react-app-rewired --dev
```

```sh
yarn remove react-app-rewired --dev
```

[1] create-react-app+react-app-rewired搭建viewport解决方案.https://segmentfault.com/a/1190000016780204



# 1 react+postcss-px-to-viewport移动端适配

首先，使用条件：

- 这本身是postcss的插件，所以需支持postcss，而现在项目中用styled-components较多，苦恼，下面有提在styled-components中如何进行移动端适配



方法：由于不想暴露webpack配置，所以用react-app-rewired+customize-cra代配置webpack，再配置px-to-viewport插件即可

安装

```sh
yarn add -D react-app-rewired customize-cra postcss-px-to-viewport
```

`pakeage.json`

```json
"start": "react-app-rewired start",
"build": "react-app-rewired build",
"test": "react-app-rewired test",
"eject": "react-scripts eject"
```

`config-overrides.js`

```js
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { override, overrideDevServer, addPostcssPlugins } = require('customize-cra')

const devServerConfig = () => (config) => {
  return {
    ...config,
    // 服务开启gzip
    compress: true,
  }
}
module.exports = {
  webpack: override(
    addPostcssPlugins([
      // 这里配置px-to-viewport
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      require('postcss-px-to-viewport')({
        viewportWidth: 375,
        unitPrecision: 3,
        viewportUnit: 'vw',
        selectorBlackList: ['.ignore', '.hairlines'],
        minPixelValue: 1,
        mediaQuery: false,
      }),
    ])
  ),
  devServer: overrideDevServer(devServerConfig()),
}
```

# 2 styled-components适配

由于 `styled-components` 插件与postcss没有联合，在互联网也没有检索到styled-components适配相关方案，只好自己摸索，如果有更好的方案，请提出，感激

思路：还是用viewport来适配，用函数计算值即可

```javascript
export function px2vw(pixels: string | number | TemplateStringsArray, pixelTotal = 375) {
  if (pixels instanceof Array) {
    // 从模板中拿去值
    pixels = pixels[0]
  }
  
  const num = parseInt(pixels as string)
  return `${((num / pixelTotal) * 100).toFixed(3)}vw`
  // 结果保留三位小数
}

// pixelTotal表示UI图宽度
```

使用

```tsx
const Content = styled.div`
	width: ${px2vw(100)};
	width: ${px2vw`100`}; // 用模板字符串也可以
	width: ${px2vw`100px`}; // 带上单位也可以

	height: ${px2vw(100)};
	
	// 媒体查询
    @media (max-width 960px){
        width: ${px2vw(50)};
        height: ${px2vw(50)};
    }
`
```

> 注意：但在自己封装的媒体查询中会出错，原因未知

```tsx
${({ theme }) => theme.mediaWidth.upToMedium`
  width: ${px2vw(200)};
  height: ${px2vw(100)};
	// 样式出错

  background: url(${bgMiniH5}) no-repeat;
  background-size: 100% 100%;
  font-size: 100px;
`};
```

解决方案：用纯媒体查询

```tsx
@media (max-width: 700px){
  width: ${px2vw`345`};
  height: ${px2vw`100`};
}
```

替换方案

```ts
(\w+px)
```

```ts
${px2vw`$1`}
```

```sh
@media (max-width: ${MEDIUM}) {
    gap: ${px2vw`12px`};
}
```





react适配关键字：`adaptive layouts with styled-component`

[1] Creating responsive and adaptive layouts with React and Styled-Components.https://dev.to/carloscne/creating-responsive-and-adaptive-layouts-with-react-and-styled-components-1ghi

# 3 rem适配

```tsx
function r(pxValue: any) {
  const ratio = 37.5 // 根据项目配置比例的方式自行设定
  pxValue = parseInt(pxValue)

  return (pxValue / ratio).toFixed(3) + 'rem'
}

export const PageWraper = styled.div`
  margin: ${r('50px')} auto 0;

  ${({ theme }) => theme.mediaWidth.upToMedium`
    margin: unset;
    width: 100%;
  `};
`
```

# 4 styled-componentd适配新方案【不太好用】

基于[5] 

```tsx
function r(pxValue) {
  const ratio = 20; // 根据项目配置比例的方式自行设定

  // 针对template literals
  if (Array.isArray(pxValue)) {
    pxValue = pxValue[0];
  }

  pxValue = parseInt(pxValue);

  return pxValue / ratio + 'rem';
}

// 把字符串样式里面的px单位换算成rem的
// 支持多行匹配
function transformPxToRem(style) {
  // 避免处理了函数等情况
  if (typeof style !== 'string') {
    return style;
  }

  return style.replace(/\d+px/gm, matched => {
    return r(matched);
  });
}

// 实现在把样式传递给styled之前，预先用transformPxToRem处理
function t(strings, ...interpolations) {
  let styles = css(strings, ...interpolations); // css是styled-components的一个helper
  styles = styles.map(transformPxToRem);

  // 模拟raw的调用
  return [[""], styles]
};
```

> 拿到设备尺寸之后，有一个上下限，在上下限中进行转换  否则不转换
>
> 待完善

（完）

参考文献

[1] styled-components中文文档.https://github.com/hengg/styled-components-docs-zh

[2] styled-components官网.https://github.com/styled-components/styled-components

[3] styled-xxxW3chool文档.https://www.w3cschool.cn/styledcomponents/styledcomponents-z8v638ja.html

[4] 移动端页面适配.https://www.jianshu.com/p/7139c05c7971【从rem到vw】

[5] 在styled-components的样式声明中做px到rem的自动转换.https://www.shuizhongyueming.com/2017/11/29/%E5%9C%A8styled-components%E7%9A%84%E6%A0%B7%E5%BC%8F%E5%A3%B0%E6%98%8E%E4%B8%AD%E5%81%9Apx%E5%88%B0rem%E7%9A%84%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2/【研究styled-comxxx的适配方案】

[6] Web移动端最强适配方案总结，没想到这么好用！.https://segmentfault.com/a/1190000038159934【比较全】

# 

# 5 通用vw适配方案

```ts
@function vw($px, $base=375) { 
  @return ($px / $base) * 100vw;
}
```



# 6 ~~styled-components适配新方案~~ 请看第7点

> ~~结果：失败了~~ **此问题已解决，请看第7点**

~~失败原因：styled-components提供的css帮助函数无法正确解析变量，最终导致一些样式出错~~

![image-20210808170205796](https://gitee.com/nahaohao/pic-upload/raw/master/img/image-20210808170205796.png)

```ts
css`
	background-color: ${(props) => props.theme.white};
`

=>>输出
    background-color: (props) => props.theme.white;
```



上代码

```ts
import { css } from 'styled-components/macro'
enum ADAPTION_MODE_VALUE {
  all = 0, // 转化所有px为vw
  media = 1, // 只转化媒体查询的px为vw
  out = 2, // TODO 只转化除媒体查询外的px为vw
}

// eslint-disable-next-line prefer-const
let ADAPTION_MODE = ADAPTION_MODE_VALUE.media // 转化模式
const DESIGNED_MEASURE = 375 // 设计稿尺寸
const MIN_PX = 1 // 最小转化值，例如：小于等于1px则不处理

const PX_REG = /(\d+)px(?!\))/
const MEDIA_REG = /{[^}]+\}/

const px2vw = (pixels: string | number | TemplateStringsArray) => {
  if (pixels instanceof Array) {
    // 从模板中拿去值
    pixels = pixels[0]
  }

  const num = parseInt(pixels as string)
  if (num <= MIN_PX) return `${num}left` // left占位，否则死循环

  return `${((num / DESIGNED_MEASURE) * 100).toFixed(3)}vw`
  // 结果保留三位小数
}

const allPx2vw = (stylesStr: string) => {
  let res: string = stylesStr

  const pxMatchReg = new RegExp(PX_REG)

  while (pxMatchReg.test(res)) {
    const pxMatchResult = pxMatchReg?.exec(res)
    if (!pxMatchResult) continue

    res = res.replace(PX_REG, `${px2vw(pxMatchResult[1])}`)
  }

  // 把占位符替换回来
  res = res.replace(/left/g, 'px')

  return res
}

const mediaPx2vw = (stylesStr: string) => {
  const mediaReg = new RegExp(MEDIA_REG)
  while (mediaReg.test(stylesStr)) {
    let mediaRegResult = mediaReg?.exec(stylesStr)?.[0]
    if (!mediaRegResult) continue

    const pxMatchReg = new RegExp(PX_REG)

    while (pxMatchReg.test(mediaRegResult)) {
      const pxMatchResult = pxMatchReg?.exec(mediaRegResult)
      if (!pxMatchResult) continue

      mediaRegResult = mediaRegResult.replace(PX_REG, `${px2vw(pxMatchResult[1])}`)
    }

    let replacedRegRes = mediaRegResult

    // 将{}替换为占位符，否则会死循环
    replacedRegRes = replacedRegRes?.replace('{', '^')
    replacedRegRes = replacedRegRes?.replace('}', '#')

    // console.log('[replacedRegRes]:', replacedRegRes)

    if (!replacedRegRes) continue

    stylesStr = stylesStr.replace(MEDIA_REG, replacedRegRes)
  }

  // 将占位符替换回来
  stylesStr = stylesStr.replace('^', '{')
  stylesStr = stylesStr.replace('#', '}')

  return stylesStr
}

// TODO 只转化除媒体查询外的px为vw

export const t = (strings: TemplateStringsArray, ...interpolations: any) => {
  console.time('t1-spend')

  const styles = css(strings, ...interpolations) // css是styled-components的一个helper

  const stylesStr = styles.join('')

  // 有三种转化情况：1.内外都转化  2.内部转化  3.外部转化【较难】
  // 这里内指的是媒体查询，外指的是媒体查询外部css
  let handledStyledStr = ''

  switch (ADAPTION_MODE) {
    case ADAPTION_MODE_VALUE.all:
      handledStyledStr = allPx2vw(stylesStr)
      break

    case ADAPTION_MODE_VALUE.media:
      handledStyledStr = mediaPx2vw(stylesStr)
      break
  }

  const handledStr = handledStyledStr.split('\n').join('')

  // console.log('[styles]:', styles, handledStr)
  console.timeEnd('t1-spend') // 性能分析
  return handledStr
}
```

使用方法，只是多包裹了一层 ${t}，而且没有代码提示了

所以可以先再外面写，然后再复制进来

```ts
const a = 200 // 不影响插值

const Wrapper = styled(Base)`
  ${t`
  width: 100px;
  height: ${a}px; // 不影响插值

  border: 1px solid red;
  @media (max-width: 960px){
    width: 100px; 
    height: 100px;
  }
`}
`
```

替换方法

```
(`[^\`]*`)

`\${$1}`
```

> vscode如何进行多行正则匹配？

```ts
[\s\S\r]*
```

例如我们要匹配下面 ``中的内容

```ts
const Base = styled.div`
  width: 200px;
`
```

 使用正则批量替换即可

```ts
((?<=[\)vn])`[\s\S\r]*?`)
```

```ts
(\n  ...t$1\n)
```

![image-20210808162506444](https://gitee.com/nahaohao/pic-upload/raw/master/img/image-20210808162506444.png)

此正则中包含正则 `预先断言`，`多行匹配`等知识，此正则表达式不会重复匹配，也就是被替换的元素不会再次被替换 如下：

```ts
const Wrapper = styled(Base)`
  width: 100px;
`
```

匹配前，匹配后，下方不会再被 `((?<=[\)vn])`[\s\S\r]*?`)`匹配

```ts
const Wrapper = styled(Base)(
  ...t`
  width: 100px;
`
)
```

> 还原的正则

```ts
\(\n  \.\.\.t(`[\s\S\r]*?`)\n\)
```

```ts
$1
```

> 更新正则

```ts
((?<=[\)vn])`[\s\S\r]*?`)
```

# 7 styled-components移动端vw适配预先处理函数

原理：通过正则匹配的方式将px替换为vw

### 实现功能

- 全部替换px为vw
- 只替换媒体查询内的px为vw

### 存在问题

- 无代码提示
- 通过props传递的参数，只有theme有提示

### 思维扩展

此函数处理是在styled-components处理之前处理，那可不可以在它处理之后我再处理呢？目前未找到相关方案，如果直接改变标签的 `rules` 是不会生效的，因为起作用的是这串hash类，而不是有名字的类，如下：所以目前只能在styled-components处理之前处理

```tsx
export const ImgBox = {
  ...imgBoxTmp,
  componentStyle: { ...imgBoxTmp.componentStyle, rules: { ...imgBoxTmp.componentStyle.rules.slice(0, 2) } },
}

console.debug('[ImgBox]:', ImgBox, ImgBox.toString())
```

![image-20210907222925602](https://gitee.com/nahaohao/pic-upload/raw/master/img/image-20210907222925602.png)

### 处理函数

```ts
/*
 * @Author: jiangjin
 * @Date: 2021-09-04 16:23:08
 * @LastEditTime: 2021-09-07 17:11:11
 * @LastEditors: jiangjin
 * @Description:
 *  styled-components的vw适配预先处理函数，通过正则替换的方式进行预处理
 */

import { css, DefaultTheme, FlattenInterpolation, Interpolation, ThemedStyledProps } from 'styled-components/macro'
enum ADAPTION_MODE_VALUE {
  all = 0, // 转化所有px为vw
  media = 1, // 只转化媒体查询的px为vw
  out = 2, // TODO 未实现，只转化除媒体查询外的px为vw
}

// 一些配置
// eslint-disable-next-line prefer-const
let ADAPTION_MODE = ADAPTION_MODE_VALUE.media // 转化模式
// let ADAPTION_MODE = ADAPTION_MODE_VALUE.all // 转化模式

const DESIGNED_MEASURE = 375 // 设计稿尺寸
const MIN_PX = 1 // 最小转化值，例如：小于等于1px则不处理

// 一些正则
const PX_REG = /(\d+)px(?!\))/
// const MEDIA_REG = /{[^}]+\}/
const MEDIA_REG = /@media([\s\S\r]+)\{[\s\S\r]+\}/
const NO_MEAN = 'NO_MEAN' // 1px占位符

// 耗时分析
const TIME_SPEED_SYMBOL = 'TIME_SPEED_SYMBOL'

// 转化核心函数
function px2vw(pixels: string | number | TemplateStringsArray) {
  if (pixels instanceof Array) {
    // 从模板中拿去值
    pixels = pixels[0]
  }

  const num = parseInt(pixels as string)
  if (num <= MIN_PX) return `${num}${NO_MEAN}` // nomean占位，否则死循环

  return `${((num / DESIGNED_MEASURE) * 100).toFixed(3)}vw`
  // 结果保留三位小数
}
/**
 *  display: flex;
  flex-direction: column;
  align-items: center;
  img {
    margin-bottom: 83px;
  }
  @media (max-width: ###960px###) {
    img {
      width: 55px;
      height: 18px;
      margin-bottom: 30px;
    }
  }
 */

// 转化所有
function allPx2vw(stylesStr: string) {
  let res: string = stylesStr

  const pxMatchReg = new RegExp(PX_REG)

  while (pxMatchReg.test(res)) {
    const pxMatchResult = pxMatchReg?.exec(res)
    if (!pxMatchResult) continue

    res = res.replace(PX_REG, `${px2vw(pxMatchResult[1])}`)
  }

  // 把占位符替换回来
  res = res.replace(/NO_MEAN/g, 'px')

  return res
}

// 只转化媒体查询
function onlyMediaPx2vw(stylesStr: string) {
  const mediaReg = new RegExp(MEDIA_REG)
  while (mediaReg.test(stylesStr)) {
    let mediaRegResult = mediaReg?.exec(stylesStr)?.[0]
    if (!mediaRegResult) continue

    const pxMatchReg = new RegExp(PX_REG)

    while (pxMatchReg.test(mediaRegResult)) {
      const pxMatchResult = pxMatchReg?.exec(mediaRegResult)
      if (!pxMatchResult) continue

      mediaRegResult = mediaRegResult.replace(PX_REG, `${px2vw(pxMatchResult[1])}`)
    }

    let replacedRegRes = mediaRegResult

    // 将{}替换为占位符，否则会死循环
    replacedRegRes = replacedRegRes?.replaceAll('{', '^^^')
    replacedRegRes = replacedRegRes?.replaceAll('}', '---')

    // console.log('[replacedRegRes]:', replacedRegRes)

    if (!replacedRegRes) continue

    stylesStr = stylesStr.replace(MEDIA_REG, replacedRegRes)
  }

  // 将占位符替换回来
  stylesStr = stylesStr.replaceAll('^^^', '{')
  stylesStr = stylesStr.replaceAll('---', '}')
  stylesStr = stylesStr.replace(/NO_MEAN/g, 'px')

  return stylesStr
}

// TODO 只转化除媒体查询外的px为vw

// 将styles转化为string，主要为了给函数打一个标记
function stringStyles(origin: FlattenInterpolation<ThemedStyledProps<Record<string, never>, DefaultTheme>>) {
  let res = ''
  const len = origin.length

  for (let i = 0; i < len; ++i) {
    const item = origin[i]

    if (typeof item !== 'string') {
      if (i == len - 1) {
        res = res + i
      } else {
        res = res + i + '###'
      }
      continue
    }

    if (i == len - 1) {
      res = res + item
    } else {
      res = res + item + '###'
    }
  }

  return res
}

// 将string转化为styles，主要为了将函数还原
function resetStyles(
  origin: string,
  styles: FlattenInterpolation<ThemedStyledProps<Record<string, never>, DefaultTheme>>
): any[] {
  const res = origin.split('###')
  const resetedStyles: any[] = []

  res.forEach((item) => {
    if (!isNaN(Number(item))) {
      // 是函数
      return resetedStyles.push(styles[Number(item)])
    }

    resetedStyles.push(item)
  })

  return resetedStyles
}

// 媒体查询预处理
function mediaPreHandler(str: string) {
  // 将媒体查询的max-width区别出来，不要转化
  const firstPxReg = /(?<=@media[\s\S\r]*?)px(?=.*\))/g
  console.log('[nounit]:', str.replaceAll(firstPxReg, 'nounit'))
  return str.replaceAll(firstPxReg, 'nounit')
}

function mediaAftHandler(str: string) {
  console.log('[resetNounit]:', str.replaceAll('nounit', 'px'))
  return str.replaceAll('nounit', 'px')
}

function convert(styles: FlattenInterpolation<ThemedStyledProps<Record<string, never>, DefaultTheme>>) {
  let stringedStyles = stringStyles(styles)
  // debugger

  // let stringedStyles = stringStyles([
  //   '\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  img {\n    margin-bottom: 83px;\n  }\n  @media (max-width: ',
  //   '960px',
  //   ') {\n    img {\n      width: 55px;\n      height: 18px;\n      margin-bottom: 30px;\n    }\n  }\n',

  //   '@media (max-width: 768px) {\n    img {\n      width: 55px;\n      height: 18px;\n      margin-bottom: 30px;\n    }\n  }\n',
  // ])
  console.debug('[stringedStyles,]:', styles, stringedStyles)

  switch (ADAPTION_MODE) {
    case ADAPTION_MODE_VALUE.all:
      stringedStyles = allPx2vw(stringedStyles)
      break

    case ADAPTION_MODE_VALUE.media:
      stringedStyles = mediaPreHandler(stringedStyles)

      stringedStyles = onlyMediaPx2vw(stringedStyles)

      stringedStyles = mediaAftHandler(stringedStyles)

      break
  }

  const resetedStyles = resetStyles(stringedStyles, styles)
  console.debug('[resetedStyles,]:', resetedStyles)
  const tmpArr: Record<any, any> = [resetedStyles]
  tmpArr['raw'] = ['']

  console.timeEnd(TIME_SPEED_SYMBOL) // 耗时分析
  return tmpArr
}

export const t = (
  strings: TemplateStringsArray,
  ...interpolations: Array<Interpolation<ThemedStyledProps<Record<string, never>, DefaultTheme>>>
) => {
  console.time(TIME_SPEED_SYMBOL)

  const styles = css(strings, ...interpolations) // css是styled-components的一个helper

  return convert(styles)
}

// function convert222(styles: FlattenSimpleInterpolation) {
//   let stringedStyles = stringStyles(styles)
//   console.debug('[stringedStyles,]:', styles, stringedStyles)

//   switch (ADAPTION_MODE) {
//     case ADAPTION_MODE_VALUE.all:
//       stringedStyles = allPx2vw(stringedStyles)
//       break

//     case ADAPTION_MODE_VALUE.media:
//       stringedStyles = onlyMediaPx2vw(stringedStyles)
//       break
//   }

//   const resetedStyles = resetStyles(stringedStyles, styles)
//   console.debug('[resetedStyles,]:', resetedStyles)
//   const tmpArr: Record<any, any> = [resetedStyles]
//   tmpArr['raw'] = ['']

//   console.timeEnd(TIME_SPEED_SYMBOL) // 耗时分析

//   return resetedStyles
// }
// export function t2<T>(themedStyledFunction: T): T {
//   console.log('[themedStyledFunction]:', themedStyledFunction)

//   const tmp = themedStyledFunction as any
//   const componentStyle = tmp?.componentStyle
//   const styles: any[] | undefined = componentStyle?.rules

//   if (!componentStyle || !styles) return themedStyledFunction

//   const convertedStyles = convert222(styles).slice(0, 2)

//   const res = { ...tmp, componentStyle: { ...componentStyle, rules: convertedStyles } }

//   console.log('[res]:', res)
//   return res
// }
// interface t2Func {
//   <T>(component: ThemedStyledFunction<C, T>;): boolean;
// }

// let t2: t2Func;

// t2 = (themedStyledFunction: ) {

//   themedStyledFunction.componentStyle
// }

// export t2
```

### 使用方法

```tsx
const DEFAULT_WIDTH = '100px'

const Wrapper = styled.div<{ width: string }>(t`
  width: 300px;
  border: 1px solid red;
  
  @media (max-width: 968px) {
    width: 100px;
    height: ${DEFAULT_WIDTH};
  }
`)
```

在原有的基础上加上(t)即可，所以可以用以下方法批量更改 `tips：建议先用一个试一下，成功后再批量替换`

- 批量替换正则

  ```sh
  (?<=styled.+?)(?<!t)(`[\s\S\r]+?`)
  替换为
  (t$1)
  ```

- 还原的正则

  ```sh
  (?<=styled.+?)\(t(`[\s\S\r]+?`)\)
  替换为
  $1
  
  \(t`([\s\S\r]*?)`\)
  替换为
  `$1`
  ```

> 注意：**请打开vscode的正则搜索模式**

![image-20210905092524035](/Users/jiangjin/Library/Application Support/typora-user-images/image-20210905092524035.png)

### 已知缺陷

目前已知的问题

- 无法转化通过标签传入的值，如下：

  ```tsx
  const Wrapper1 = styled.div<{ width: string }>(t`
    width: 300px;
    @media (max-width: 2000px) {
  		width: ${(props: any) => props.width}; // 标签传入变量无法实现转化
      height: ${DEFAULT_WIDTH}; // 普通外部变量可以转化
      border: 1px solid red;
    }
  `)
  ```

  原因：通过标签传入的变量在styled-components工作的时候才能确定其值，而本函数是预处理（之前），无法获取到 `未来的值`，所以无法进行转化。所以需要转化的值，不要通过标签传值的方式传入。

- 没有代码提示了

  原因：代码写在t函数内部，`vscode-styled-components`无法处理，所以没有代码提示

  解决方案：正常书写，最后再批量替换为t函数处理

  但可以让代码高亮，在插件的 `styled-components.json` 文件中

  ```sh
  将begin中的 ` 修改为 t?`即可
  ```

  ```json
  {
    "contentName": "source.css.scss",
    "begin": "(?:(?:([\\s\\S][sS][tT][yY][lL][eE][dD](?:<.+>(?=\\())?(?:\\.[_$[:alpha:]][_$[:alnum:]]*|\\s*\\(['\"][_$[:alpha:]][_$[:alnum:]]*['\"]\\)|\\s*\\((.+)\\))(?:\\s*<.+>)?\\(?)|(css|keyframes|injectGlobal|createGlobalStyle|stylesheet)(<.+>)?)\\s*(\\([\\{\\}\\w,\\:\\s]+?\\)\\s*=>\\s*)?(t?`))|(?:}>|\\)\\))(t?`)",
    "beginCaptures": {
  ```

> 联想：**mac vscode插件位置**

**Mac下vscode插件存放位置：** `User/（你的用户名）/.vscode/extensions`

需显示隐藏文件，方法：

打开Finder，转到Macintosh HD文件夹（从左栏中的设备访问），按住Cmd + Shift + . 所有隐藏文件都将变为可见

# 8 一些币链接

芝麻开门.https://www.gate.io/cn/trade/BNB_USDT

138...7-n...3

BNB.https://www.binance.com/zh-CN/trade/BTC_USDT?layout=basic

g...98...gmail-d...2

# 9 js普通数字转科学计数法

而在JavaScript中有一个方法能将数字转化为科学计数法，那就是[toExponential](http://www.w3school.com.cn/jsref/jsref_toexponential.asp)。

该方法可把对象的值转换成指数计数法。`NumberObject.toExponential(num)`中的参数`num`规定指数计数法中的小数位数，是 0 ~ 20 之间的值，包括 0 和 20，有些实现可以支持更大的数值范围。如果省略了该参数，将使用尽可能多的数字。

例如：

```ts
var num = 123456;

num.toExponential() //"1.23456e+5"
num.toExponential(1) //"1.23e+5"
```

反过来，将一个科学计数法的数字转化为普通数字：

```ts
var eNum = "1.23456e+5";

Number(eNum) //123456
or eNum.toFixed()
```

