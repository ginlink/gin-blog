---
title: 018.JS异步
categories:
  - 大前端
tags:
  - 异步
  - JS异步
---

我们知道js异步代码有：callback（回调函数），promise，generator，async/await



## Promise.all按照请求顺序返回结果

```ts
function mkPromise(id, delay) {
    return new Promise((re, rj) => {
        const msg = `我是ID为 ${id} 的定时器，delay为 ${delay}`

        setTimeout(() => {
            re(msg)
        }, delay);
    })
}

function main() {
  let tmpArr = [
    mkPromise(1, 5000),
    mkPromise(2, 4000),
    mkPromise(3, 3000),
    mkPromise(4, 2000),
    mkPromise(5, 1000),
  ]

  Promise.all(tmpArr).then((res) => {
    console.log('[res]:', res)
  }).catch((err) => {
    console.log('[err]:', err)
  });

}

main()

=>>>
    [res]: [
        '我是ID为 1 的定时器，delay为 5000',
        '我是ID为 2 的定时器，delay为 4000',
        '我是ID为 3 的定时器，delay为 3000',
        '我是ID为 4 的定时器，delay为 2000',
        '我是ID为 5 的定时器，delay为 1000'
    ]
```

> 联想：**Promise.all中有一个出错，则本次所有调用失败（reject）**，那么如何避免`死一条鱼，臭一条河`？

如果其中有一个promise请求时间特别长，容易失败，导致整体失败，那如何避免这个问题呢？用Promise.race定义一个最大超时时间

```ts
const MAX_DELAY = 3001
const mkPromise = (id, delay) => {
    // return _mkPromise(id, delay)
    // return Promise.race([_mkPromise(id, delay), _racePromise()])
    return Promise.race([_mkPromise(id, delay), new Promise((re) => {
        setTimeout(() => {
            re('超时了')
        }, MAX_DELAY);
    })])

    function _mkPromise(id, delay) {
        return new Promise((re, rj) => {
            const msg = `我是ID为 ${id} 的定时器，delay为 ${delay}`

            setTimeout(() => {

                // if (id == 3)
                //   rj('[err:]' + msg)
                // else
                //   re(msg)

                re(msg)
            }, delay);
        })
    }
}

=>>>
    [res]: [
        '超时了',
        '超时了',
        '我是ID为 3 的定时器，delay为 3000',
        '我是ID为 4 的定时器，delay为 2000',
        '我是ID为 5 的定时器，delay为 1000'
    ]
```

