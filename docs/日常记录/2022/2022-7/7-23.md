---
sidebar_position: 2
title: 7-23
tags:
  - 日常记录
---



## 1 前端AES加密

### 依赖

```sh
yarn add crypto-js
yarn add -D @types/crypto-js
```

### 示例

```ts
import CryptoJS from 'crypto-js'

const key = '6fa979f20126cb08aa645a8f495f6d85';
const iv = 'I8zyA4lVhMCaJ5Kg';

const utf8PubKeyArr = CryptoJS.enc.Utf8.parse(key)
const utf8IvArr = CryptoJS.enc.Utf8.parse(iv)

// Encrypt
export function getBase64AESCode(origin: string) {
  const res = CryptoJS.AES.encrypt(origin, utf8PubKeyArr, {
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7,
    iv: utf8IvArr,
  }).ciphertext

  return CryptoJS.enc.Base64.stringify(res)
}

// Decrypt
export function parseBase64AESCode(base64Encrypted: string) {
  const encrypted = CryptoJS.lib.CipherParams.create({
    ciphertext: CryptoJS.enc.Base64.parse(base64Encrypted),
  })

  return CryptoJS.AES.decrypt(encrypted, utf8PubKeyArr, {
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7,
    iv: utf8IvArr,
  }).toString(CryptoJS.enc.Utf8)
}
```

### 数据转换

在cryptojs中存在几种数据格式：

- string 

  普通string，编码格式可能是utf8、GBK、GB2312等等

  将string通过utf8去解析为WordArray

  ```ts
  const arr = CryptoJS.enc.Utf8.parse('123')
  ```

- WordArray

  是一种通用格式

  可以进行一些转换，示例见 https://www.cnblogs.com/qiqi715/p/9623421.html

- CryptoJS.lib.CipherParams

  生成一个CipherParams

  ```ts
  const params = CryptoJS.lib.CipherParams.create({
    ciphertext: CryptoJS.enc.Base64.parse('123'),
  })
  ```

- 编码为utf8的string

  一般高级类型（例如：WordArray、CipherParams），转化为string的时候可以选择编码格式

  ```ts
  const arr = CryptoJS.enc.Utf8.parse('123')
  arr.toString(CryptoJS.enc.Utf8)
  =>> '123'
  ```

### ~~rsa256~~

rsa256通过 [jsencrypt](https://www.npmjs.com/package/jsencrypt) 包使用，但该包只能在客户端使用，无法正常用于nextjs，所以改用aes

### 参考

[1] https://cryptojs.gitbook.io/docs/

![image-20220725221638337](https://cdn.gincool.com/img/image-20220725221638337.png)

[2] [CryptoJS encrypt in aes-256-cbc returns an unexpected value](https://stackoverflow.com/questions/57416217/cryptojs-encrypt-in-aes-256-cbc-returns-an-unexpected-value)

![image-20220725221607388](https://cdn.gincool.com/img/image-20220725221607388.png)

[3] [在线aes装换](https://the-x.cn/cryptography/Aes.aspx)

![image-20220725221535025](https://cdn.gincool.com/img/image-20220725221535025.png)

## 2 algolia爬虫

https://crawler.algolia.com

![image-20220725230023083](https://cdn.gincool.com/img/image-20220725230023083.png)

## 3 Eslint与mocha

让vscode识别mocha，`.eslintrc` 中：

```js
"env": {
  "commonjs": true,
  "node": true,
  "mocha": true
},
```

[1] https://stackoverflow.com/questions/30018271/javascript-standard-style-does-not-recognize-mocha

## 4 元素在页面移动

https://sui.io/

![image-20220727220815150](https://cdn.gincool.com/img/image-20220727220815150.png)

### 原理

```css
@keyframe movingleftright3{
  0% {
    transform: translateX(0) translateY(0);
  }
  40% {
    transform: translateX(100px) translateY(-200px);
  }
  75% {
    transform: translateX(-500px);
  }
  100% {
    transform: translateY(0) translateX(0);
  }
}
```

```css
animation: movingleftright3 20s infinite;
```

## 5 React的CreateElement

### 作用

CreateElement输入 type、props、children 用于创建如下结构：

```ts
type Element = {
  type: string
  props: Record<string, any>
}
```

可以看到与输入相比，输出结构中将 children 放到了props中

### 重点

如果是文本就创建一个文本节点

## 5 React的ConcurrentMode原理

### 核心点

在于两点：1.浏览器空闲时间 2.根据fiber创建dom

总结一句话：在浏览器有空闲时间时，根据fiber创建DOM

### 核心函数

```ts
function perForUnitWork(fiber) {
  // 创建DOM
  // 为当前fiber创建子fiber
  // 返回下一个执行单元

  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }

  if (fiber.parent) {
    fiber.parent.dom.appendChild(fiber.dom)
  }

  const children = fiber.props?.children
  let prevChild;
  children && children.forEach((child, index) => {
    const newFiber = {
      parent: fiber,
      type: child.type,
      props: child.props,
      dom: undefined
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevChild.sibling = newFiber
    }

    prevChild = newFiber
  })

  if (fiber.child) {
    return fiber.child
  }

  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }

    nextFiber = nextFiber.parent
  }
}

function workLoop(deadline) {
  // 是否有空闲时间
  // 是否有任务
  // 渲染节点

  let shouldYield = true
  if (shouldYield && nextUnitWork) {
    nextUnitWork = perForUnitWork(nextUnitWork)
    shouldYield = deadline.timeRemaining > 1
  }

  requestIdleCallback(workLoop)
}

requestIdleCallback(workLoop)
```

### Fiber

截止目前（2022-07-27 23:30:23），我了解的Fiber表示一种数据结构，如下：

```ts
type Fiber = {
  type: string;
  props: Record<string, any> & {
    children: Element[]
  };
  dom: any;
  parent: Fiber;
}
```

> TODO 调研真正的Fiber结构

### Fiber树生成顺序

![image-20220727234912629](https://cdn.gincool.com/img/image-20220727234912629.png)
