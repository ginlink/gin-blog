---
sidebar_position: 1
title: 10-8
tags:
  - 日常记录
---



# 1 Prettier和Eslint的关系

Prettier是一个代码格式化工具，Eslint是一种规范和工具，而vscode的eslint和prettier插件则是用于支持，和在保存中自动进行格式化代码

### 有一些插件（代码方面）：

- prettier：prettier的核心
- eslint-config-prettier：解决ESLint中的样式规范和prettier中样式规范的冲突，以prettier的样式规范为准，使ESLint中的样式规范自动失效
- eslint-plugin-prettier：将prettier作为ESLint规范来使用

### 另外一些插件（vscode方面）：

- ESLint，下面是vscode的配置

  ```json
  //.setting.json
  {
    "eslint.enable": true,  //是否开启vscode的eslint
    "eslint.autoFixOnSave": true, //是否在保存的时候自动fix eslint
    "eslint.options": {    //指定vscode的eslint所处理的文件的后缀
      "extensions": [
        ".js",
        ".vue",
        ".ts",
        ".tsx"
      ]
    },
    "eslint.validate": [     //确定校验准则
      "javascript",
      "javascriptreact",
      {
        "language": "html",
        "autoFix": true
      },
      {
        "language": "vue",
        "autoFix": true
      },
      {
        "language": "typescript",
        "autoFix": true
      },
      {
        "language": "typescriptreact",
        "autoFix": true
      }
    ]
  }
  ```

  配置中，主要注意的有两点：

  - eslint.options中可以通过configFile属性来执行eslint规范的绝对路径，默认会向上查找，在根路径中指定。
  - eslint.validate中必须通过{ language: XXX}的形式来指定typescript和typescriptreact

### 实例：React+ts项目中配置eslint

```json
//.eslintrc.json
{
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": 2020,
    "sourceType": "module",
    "ecmaFeatures": {
      // Allows for the parsing of JSX
      "jsx": true
    }
  },
  "ignorePatterns": ["node_modules/**/*", "src/plugins/@uniswap/**/*"],
  "settings": {
    "react": {
      "version": "detect"
    }
  },
  "extends": [
    "plugin:react/recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:react-hooks/recommended",
    "prettier/@typescript-eslint",
    "plugin:prettier/recommended"
  ],
  "rules": {
    "@typescript-eslint/explicit-function-return-type": "off",
    "prettier/prettier": "error",
    "@typescript-eslint/no-explicit-any": "off",
    "@typescript-eslint/ban-ts-comment": "off",
    "@typescript-eslint/ban-ts-ignore": "off",
    "@typescript-eslint/explicit-module-boundary-types": "off"
  }
}
```

```json
//.prettierrc
{
  "semi": false,
  "singleQuote": true,
  "printWidth": 120
}
```

附：tsconfig.json配置

```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "strict": true,
    "alwaysStrict": true,
    "strictNullChecks": true,
    "noUnusedLocals": false,
    "noFallthroughCasesInSwitch": true,
    "noImplicitAny": true,
    "noImplicitThis": true,
    "noImplicitReturns": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "downlevelIteration": true,
    "allowSyntheticDefaultImports": true,
    "types": ["react-spring", "jest"],
    "baseUrl": "src"
  },
  "exclude": ["node_modules", "cypress"],
  "include": ["./src/**/*.ts", "./src/**/*.tsx", "src/components/Confetti/index.js"]
}
```



参考

[1] 在Typescript项目中，如何优雅的使用ESLint和Prettier.https://segmentfault.com/a/1190000019661168

[2] uniswap前端项目.https://github.com/Uniswap/interface

# 2 Eslint和Tslint的关系

### 共同点：

Eslint 可以静态检查 [javascript](https://cloud.tencent.com/product/sms?from=10680) 代码一些逻辑上的错误，还有一些代码格式的错误。原理是把代码 parse 成 AST，然后基于 AST 来检查一些问题。

Tslint 可以静态检查 typescript 代码的一些逻辑上的错误，一些代码格式的错误。原理也是基于 AST 的。

### 不同点：

Eslint包含Tslint，`对于Typescript项目的编码规范而言，主要有两种选择ESLint和TSLint。ESLint不仅能规范js代码，通过配置解析器，也能规范TS代码。此外由于性能问题，TypeScript 官方决定全面采用ESLint，甚至把仓库作为测试平台，而 ESLint 的 TypeScript 解析器也成为独立项目，专注解决双方兼容性问题。`

[1] 在Typescript项目中，如何优雅的使用ESLint和Prettier.https://segmentfault.com/a/1190000019661168

[2] TSLint 和 ESLint 是怎么融合在一起的.https://cloud.tencent.com/developer/article/1883568

## 联想：有哪些AST，它们之间有什么区别呢？

eslint 有自己的 espree 的 parser 和相应的 AST。

typescript 也有自己的 parser 和相应的 AST。

babel 也有自己的 parser 和相应的 AST。

### 为什么会出现这么多parser？

因为它们有自己的语法，需要自己去解析

### 总结

js 有不同的 parser，分为 estree 系列和非 estree 系列：

- estree 系列有 esprima、acorn 以及扩展自 acorn 的 espree、babel parser 等。
- 非 estree 系列有 typescript、terser 等。

eslint 中支持了 parser 的切换，可以在 babel parser、vue template parser、typescript 和 espree 中切换，当然也可以扩展其他的 parser。

[1] TSLint 和 ESLint 是怎么融合在一起的.https://cloud.tencent.com/developer/article/1883568

# 3 nest-新手

### 一些文档：

nest中文文档仓库：https://github.com/nestcn/docs.nestjs.cn

nest中文文档：https://docs.nestjs.cn/8/introduction

nest英文文档：https://nextjs.org

nest+next前后台博客项目：https://github.com/fantasticit/wipi

### 问题1：一名node后端开发者需要掌握哪些内容？哪些板块？

> TODO

## Nestjs

### dto与interface的关系？

dto：dataTransferObject（数据传输对象）是一个js对象，在TS转化后会保留

Interface：是一个接口，TS转化后会被删除

## 异常过滤器

作用：捕获异常，给客户端做出相应

思路：定义异常过滤器，设置好需要捕获的异常类型（如果不设置，则为空），最后再注册

可以注册到方法，控制器或全局

:warning: 主要逻辑为实现 `ExceptionFilter` 接口，再重写 `catch` 方法

```ts
//定义
import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';
import { Request, Response } from 'express';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    const status = exception.getStatus();

    response
      .status(status)
      .json({
        statusCode: status,
        timestamp: new Date().toISOString(),
        path: request.url,
      });
  }
}
```

```ts
//注册到方法
@Post()
@UseFilters(HttpExceptionFilter) //这里最好用类，而非实例
async create(@Body() createCatDto: CreateCatDto) {
  throw new ForbiddenException();
}

//注册到控制器
@UseFilters(new HttpExceptionFilter())
export class CatsController {}

//注册到全局
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalFilters(new HttpExceptionFilter());
  
  await app.listen(3000);
}
```

## 管道

说明：管道与异常过滤器类似，也是在客户端与路由处理之间的一层处理，它可以进行数据的 `验证` 和 `转化`

### 验证

主要验证什么呢？验证参数是否合法

例如自带的ValidationPipe，使用实例如下（注意安装class-validator和class-transformer包）：

```ts
class CreateCatDto {
  //name属性必须为string，如果不合法，那么返回403
  @IsString()
  name: string;
}

@Controller('cats')
export class CatsController {
  // 注入服务
  constructor(private catsService: CatsService) {}

  @Post()
  @UsePipes(ValidationPipe) //使用管道验证客户端传入数据是否合法
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto);

    return '创建成功';
  }
}
```

### 转化

将数据转化，例如自带的ParseIntPipe（将参数转化为int）

```ts
@Get(':id')
async findOne(@Param('id', new ParseIntPipe()) id) {
  return await this.catsService.findOne(id);
}
```

问题一：如何自定义转化函数呢？

## 守卫

问：守卫、中间件、异常过滤器、管道、拦截器的通过顺序是怎样的？

<img src="https://cdn.gincool.com//img/image-20211115124218376.png" alt="image-20211115124218376" style="zoom: 67%;" />

守卫可以进行鉴权

[1] Nest中的中间件、守卫、管道、异常过滤器和拦截器.https://juejin.cn/post/7002229947414609933

[2] Nest学习导图.https://blog.csdn.net/weixin_44828005/article/details/115499297

# 4 mac如何生成安卓证书（.keystore）?

请google

别名：test.keystore

密码：j...3

# 5 ssh_exchange_identification: Connection closed by remote host-ssh无法连接

原因：公司今天梯子突然用不了了，之后自己挂梯子能上github网站，但无法拉/推代码 怀疑是代理提前错误解析了github的地址

解决方案：替换hosts，让本机知道github.com的真实地址

### 第一步：查看github的IP

```sh
https://websites.ipaddress.com/github.com
=>
  我这里查到的是140.82.112.4
```

### 第二步：修改hosts

```sh
sudo vim /etc/hosts
```

追加如下内容：

```sh
# Github
140.82.112.4 github.com
```

### 第三步：验证

```sh
ssh git@github.com -vvv
```

如果出现 `Bytes per second: sent 6328.5, received 6052.3` 字样则成功

[1] ssh -T git@github.com 出现 ssh_exchange_identification: Connection closed by remote host 的错误.https://www.v2ex.com/t/290545

[2] github修改IP.https://blog.csdn.net/weixin_34290096/article/details/93088345

```sh
⁣https://api.thegraph.com/subgraphs/name/hfersss/sheepdex⁣

https://api.thegraph.com/subgraphs/name/hfersss/sheepdex
```

### 相关问题一：fatal: unable to access 'https://github.com/ginlink/lua-learn-for-grow.git/': OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054

解决方案：采用ssh的方式登陆，不要用https

```sh
https://github.com/ginlink/lua-learn-for-grow.git/

改为
git@github.com:ginlink/lua-learn-for-grow.git
```

# 6 Fix Windows Update Error 0x800b0109

[1] Fix Windows Update Error 0x800b0109.https://www.digitbin.com/fix-error-0x800b0109-windows-update/

# 7 apple M1 打包的镜像在 Linux运行

加上平台参数即可，例如：

```sh
docker build --platform linux/amd64 -t test/demo-docker .
```

[1] apple M1 打包镜像在 Linux运行.https://blog.csdn.net/weiyi556/article/details/115111917

# 8 vac_mock_list_data

```json
{
  "code": 1,
  "data": {
    "list": [
      {
        "id": 1,
        "icon": "/static/img/stuCenter/vacation.svg",
        "title": "请销假",
        "url": "/pages/vacation/vacation"
      },
      {
        "id": 1,
        "icon": "/static/img/stuCenter/write.svg",
        "title": "健康晨报",
        "url": "/pages/vacation/vacation"
      },
      {
        "id": 1,
        "icon": "/static/img/stuCenter/write.svg",
        "title": "健康日报",
        "url": "/pages/vacation/vacation"
      },{
        "id": 1,
        "icon": "/static/img/stuCenter/apply.svg",
        "title": "返校申请",
        "url": "/pages/vacation/vacation"
      },{
        "id": 1,
        "icon": "/static/img/stuCenter/apply.svg",
        "title": "离返校登记",
        "url": "/pages/vacation/vacation"
      },{
        "id": 1,
        "icon": "/static/img/stuCenter/notify.svg",
        "title": "通知公告",
        "url": "/pages/vacation/vacation"
      },{
        "id": 1,
        "icon": "/static/img/stuCenter/apply.svg",
        "title": "课堂缺勤记录",
        "url": "/pages/vacation/vacation"
      },{
        "id": 1,
        "icon": "/static/img/stuCenter/apply.svg",
        "title": "课堂评价",
        "url": "/pages/vacation/vacation"
      },{
        "id": 1,
        "icon": "/static/img/stuCenter/help.svg",
        "title": "使用帮助",
        "url": "/pages/vacation/vacation"
      }
    ]
  }
}

```

# 9 seo - 如何强制 Telegram 更新链接预览？

解决方案：要通过telegram的刷新机器人进行刷新

### 第一步：给html添加prefix属性

```html
<html prefix="og: http://ogp.me/ns#">
```

### 第二步：给 [@webpagebot](https://telegram.me/webpagebot) 发送一个更新消息

 [@webpagebot](https://telegram.me/webpagebot)

参考

[1] seo - 如何强制 Telegram 更新链接预览？.https://www.coder.work/article/842107

[2] How to force telegram to update link preview?.https://stackoverflow.com/questions/35268940/how-to-force-telegram-to-update-link-preview

# 10 移动端禁用缩放-禁止

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0,user-scalable=no"/>
```

[1] 移动端禁止用户缩放页面完整meta写法.https://blog.csdn.net/guochao8/article/details/82931326

# 11 uniapp创建vue3+ts的项目

通过 `cli` 的方式创建

### 错误：Module '"vue"' has no exported member 'ref'. 

原因：

解决方案：给 `tsconfig.json` 中加入include属性

```json
"include": [
  "./src/**/*.ts",
],
```

# 12 为vuex的modules添加类型

```ts
import { createStore } from 'vuex'
import application from './application'
import user from './user'

// 重点
interface ModuleState {
  application: typeof application.state
  user: typeof user.state
}

const store = createStore<ModuleState>({
  modules: {
    application,
    user,
  },
})
export default store
```

[1] vuex对ts的支持太弱？想要获得vuex的智能提示？一个让 vuex 更好的支持 typescript 的解决方案.https://segmentfault.com/a/1190000019628996

# 13 vite postcss

目的：1.进行移动端适配（vw） 2.进行css转化（兼容性处理）

Vite自身已经集成PostCSS

[1] vite postcss.https://www.jianshu.com/p/21be605c6ad1

# 14 关于别名@设置

问：别名设置与什么有关？vue？react？typescript？

> TODO

[1] vue 别名路径智能提示配置.https://www.cnblogs.com/boyyangD/articles/15015793.html

# 15 uniapp进行vue3+ts+vite开发

:x: 目前（2021-11-15 14:21:41），不建议使用uniapp的vue3版本，因为一些三方包没有升级到vue3

目前有两种方式：

- 第一，利用hbuilder创建 `uni-app` 项目；
- 第二，利用cli创建；

但第二种有缺陷，APP/H5与小程序需要不同的方式创建，所以建议用hbuilder创建。

创建步骤：

### 第一步：通过hbuilder创建uni-app项目，选择 `uni-ui`

创建好的项目，包含基本uniapp项目结构（但是用vite搭建的），现在需要选择vue3版本，然后再配置ts

### 第二步：选择vue3版本

manifest.json文件中选择vue3版本

### 第三步：根据官网升级指南中的 `使用 ts 开发 uni-app` 配置ts

- 将 `main.js` 修改为 `main.ts`
- 同时，index.html 中引用路径 `src="/src/main.js"` 改为 `src="/src/main.ts"`
- 将 vue 文件中 `<script>` 标签的语言属性设置为 ts, `<script lang="ts">`
- 安装 typescript 包
  - HBuilder X 项目运行时会提示安装，按提示操作即可
  - cli 项目需要手动安装，`npm i typescript`

通过以上配置，此项目已经是vue3+ts+vite的项目，如果我们要在vscode中开发，但vscode报错怎么办？

所有配置的内容只在hbuilder中封装好了，但vscode不知道，所有需要安装一些开发工具让vscode也知道

下面是 `package.json`

```json
{
  "name": "yue-code",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "devDependencies": {
    "@dcloudio/types": "^2.5.10",
    "@vitejs/plugin-vue": "^1.6.0"
  },
  "dependencies": {
    "vue": "^3.2.20",
    "vuex": "^4.0.2"
  }
}
```

`.sfc.d.ts`

```ts
declare module "*.vue" {
  import Vue from 'vue'
  export default Vue
}

declare module 'vue' {
  import { CompatVue } from '@vue/runtime-dom'
  const Vue: CompatVue
  export default Vue
  export * from '@vue/runtime-dom'
}
```

`tsconfig.json`

```json
{
	"compilerOptions": {
		"target": "esnext",
		"module": "esnext",
		"strict": true,
		"jsx": "preserve",
		"importHelpers": true,
		"moduleResolution": "node",
		"esModuleInterop": true,
		"allowSyntheticDefaultImports": true,
		"experimentalDecorators": true,
		"sourceMap": true,
		"skipLibCheck": true,
		"baseUrl": ".",
		"types": [
			"@dcloudio/types"
			// "miniprogram-api-typings",
			// "mini-types"
		],
		"paths": {
			"@/*": [
				"./*"
			]
			// 路劲别名到根
		},
		"lib": [
			"esnext",
			"dom",
			"dom.iterable",
			"scripthost"
		]
	},
	"exclude": [
		"node_modules",
		"unpackage",
		"src/**/*.nvue"
	]
}
```

### 已知问题

- 无法配置vite.config.js(ts)，例如配置别名，配置之后项目进入空白页面，无任何提示

### 项目地址

https://gitee.com/nahaohao/uniapp-vue3-ts-vite

参考

[1] uni-app 项目支持 vue 3.0介绍，及升级指南.https://ask.dcloud.net.cn/article/37834

[2] vue3官网.用于迁移的构建版本.https://v3.cn.vuejs.org/guide/migration/migration-build.html#%E6%A6%82%E8%BF%B0

[3] vue3官网.TypeScript 支持.https://v3.cn.vuejs.org/guide/typescript-support.html#npm-%E5%8C%85%E4%B8%AD%E7%9A%84%E5%AE%98%E6%96%B9%E5%A3%B0%E6%98%8E

# 16 git查看当前追踪分支

```sh
git branch -vv

==>
develop 0b7833b [origin/develop] fix: 修复@别名配置
* master  0b7833b [origin/master] fix: 修复@别名配置
```

可以看到当前master追踪的origin/master分支，develop追踪的origin/develop

追踪后，git push或者git pull，就默认与该追踪分支进行交互

### 联想：如何设置追踪分支？

设置分支develop追踪远端分支的developxxxxxxxxxx git branch --set-upstream develop origin/develop前提是本地都有这两个分支检出远端分支，并设置追踪（最常用）xxxxxxxxxx git checkout -b develop origin/develop前提是有origin/develop分支设置当前分支追踪origin/developxxxxxxxxxx git branch -u origin/develop

[1] git跟踪远程分支，查看本地分支追踪和远程分支的关系.https://www.cnblogs.com/mafeng/p/10137244.html

# 17 manifest.json作用

[Web应用程序清单](https://developer.mozilla.org/zh-CN/docs/Web/web app manifest)在一个JSON文本文件中提供有关应用程序的信息（如名称，作者，图标和描述）。manifest 的目的是将Web应用程序安装到设备的主屏幕，为用户提供更快的访问和更丰富的体验。

### 实例

```json
{
  "background_color": "#fff",
  "display": "standalone",
  "homepage_url": "https://sheepdex.org",
  "icons": [
    {
      "src": "./images/192x192_App_Icon.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "./images/512x512_App_Icon.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ],
  "orientation": "portrait",
  "name": "SheepDEX",
  "short_name": "SheepDEX",
  "start_url": ".",
  "theme_color": "#0958B4"
}
```

一些字段说明：

- display：定义开发人员对Web应用程序的首选显示模式。
- orientation：定义所有Web应用程序顶级的默认方向 [browsing contexts](https://developer.mozilla.org/zh-CN/docs/Glossary/Browsing_context).

[1] Web App Manifest.https://developer.mozilla.org/zh-CN/docs/Web/Manifest

### 联想：如何在社交应用上创建网站预览图？增强seo

例如：Fackbook、Telegram、Twitter等

解决方案：添加og协议头

```html
<meta property=”og:image” content=”http://g1.ykimg.com/0100641F464A ... 9-76EA-E5E20A1887C4″/>
```

除了支持image，还有其他属性

```html
<meta property=”og:type” content=”video”/>
<meta property=”og:title” content=”五月天_突然好想你MV现场版”/>
<meta property=”og:image” content=”http://g1.ykimg.com/0100641F464A ... 9-76EA-E5E20A1887C4″/>
<meta property=”og:url” content=”http://v.youku.com/v_show/id_XMTIyMTY5Nz...”/>
<meta property=”og:videosrc” content=”http://player.youku.com/player.p ... AutoPlay=true/v.swf”/>
<meta property=”og:width” content=”500″ />
<meta property=”og:height” content=”416″ />
```

给telegram添加预览图

第一步：

```html
<html prefix="og: http://ogp.me/ns#">
```

第二步：然后再给telegram机器人一条刷新指令即可

[1] How to force telegram to update link preview?.https://stackoverflow.com/questions/35268940/how-to-force-telegram-to-update-link-preview

# 18 一个圆形阴影-css-box-shadow

```css
div {
  width:100px;
  height:100px;
  margin: 100px auto;
  background-color:#ff8888;
  border:1px solid #000;
  border-radius: 50%;
  box-shadow: 10px 10px 5px #888888,
    10px 10px 5px #888 inset;
}
```

效果

![image-20211014131106957](https://cdn.gincool.com//img/image-20211014131106957.png)

[1] CSS 边框 轮廓 阴影.https://segmentfault.com/a/1190000003846548

# 19 Js深拷贝

Lodash太大，所以引入一个手写的深拷贝

```js
function deepClone(obj) {
  if (obj === null) return null; //null 的情况
  if (obj instanceof RegExp) return new RegExp(obj); //正则表达式的情况
  if (obj instanceof Date) return new Date(obj); //日期对象的情况
  if (typeof obj == 'Function') return new function(obj){}; //函数的情况
  if (typeof obj != "object") {
    //非复杂类型,直接返回 也是结束递归的条件
    return obj
  }
  //[].__proto__.constructor=Array()
  //{}.__proto__.constructor=Object()
  //因此处理数组的情况时,可以取巧用这个办法来new新对象
  var newObj = new obj.__proto__.constructor;
  for (var key in obj) {
    newObj[key] = deepClone(obj[key])
  }
  return newObj;
}
```

### 问题一：`__proto__` 具有兼容性问题，如何处理？

利用 `Object.create` 代替 `__proto__`

### :warning: 问题二：deepClone中的循环引用是什么导致的？相同引用又是什么？如何解决呢？

引用分为两种：循环引用和相同引用

```ts
//循环引用，一个类中一个属性引用自身
const circle = {}

circle.circle = circle

//相同引用，一个类中多个属性引用相同的对象
const obj = {}
const arr = []

obj.arr1 = arr
obj.arr2 = arr
```

:white_check_mark: 如何解决深拷贝中的引用问题呢？

思想：用一个对象（或者map）记录一下出现的所有属性，在每次拷贝之前检查一下在记录中否？如果在，直接取原有的，不在则取当前的。

具体实现：

```ts
function deepClone(origin: any) {
  const map = new Map()
  return baseClone(origin)

  function baseClone(origin: any) {
    // 1.条件
    if (origin === null || origin === undefined) return origin

    if (origin instanceof Date) return new Date(origin.getTime())
    if (origin instanceof RegExp) return new RegExp(origin)

    const type = typeof origin
    // if(type === 'function') return new Function('return' + origin.toString())()
    // if(type === 'function') return new function(origin){}
    // if(type === 'function') return new function(origin){}
    // 拷贝函数有问题，如果函数内部有闭包量，那么会失败
    // TODO目前函数并未实现深拷贝

    if (type !== 'object') return origin

    // 2.递归
    const keys = Object.keys(origin)
    let target = null

    target = origin instanceof Array ? [] : Object.create(origin)

    //用当前值和origin比较，值是新创建数据本身
    map.set(origin, target)

    const len = keys.length
    for (let i = 0; i < len; ++i) {
      const key = keys[i]
      const value = origin[key]

      if (map.has(value)) {
        target[key] = map.get(value)
      } else {
        target[key] = deepClone(value)
        // 注意：数组也可以通过arr['0']的方式去赋值
      }
    }

    return target
  }
}
```

[1] 原生js实现深拷贝.https://juejin.cn/post/6844903967923650573

~~[2] 解决循环引用和相同引用的js深拷贝实现(BFS).https://segmentfault.com/a/1190000021682472~~

[3] JavaScript 拷贝 函数方式.https://blog.csdn.net/Altaba/article/details/103916762

# 20 uniapp的云数据库、云储存

:x: 目前先不了解云函数和数据库

描述：可以通过 `云函数` 去操作云数据库、云储存，而云函数可以绑定域名，就相当于一个接口，例如：`https://30784075-9ca0-4ed8-93cb-edd05313f768.bspapp.com/api/register`

此域名可以用于微信小程序

下面是使用云数据库的实例：https://segmentfault.com/a/1190000039896915

# 21 MongoDB

目的：学习MongoDB，为使用云数据库打基础（都为非关系型文档数据库）

环境：MongoDB版本为4.2

学习方式：看阅中文文档为目录，具体阅读英文文档，因为英文文档有在线shell（可以直接尝试）

中文文档路径：https://docs.mongoing.com/mongo-introduction/documents

英文文档路径：https://docs.mongodb.com/v4.2/tutorial/query-documents/

### 学习重点

- 增删改查

## 插入



## 查询

### 查询返回字段

```sh
db.inventory.insertMany( [ 
    { item: "journal", status: "A", size: { h: 14, w: 21, uom: "cm" }, instock: [ { warehouse: "A", qty: 5 } ] },
    { item: "notebook", status: "A",  size: { h: 8.5, w: 11, uom: "in" }, instock: [ { warehouse: "C", qty: 5 } ] },
    { item: "paper", status: "D", size: { h: 8.5, w: 11, uom: "in" }, instock: [ { warehouse: "A", qty: 60 } ] },
    { item: "planner", status: "D", size: { h: 22.85, w: 30, uom: "cm" }, instock: [ { warehouse: "A", qty: 40 } ] },
    { item: "postcard", status: "A", size: { h: 10, w: 15.25, uom: "cm" }, instock: [ { warehouse: "B", qty: 15 }, { warehouse: "C", qty: 35 } ] }
]);
```

`db.collection.find(查询条件, 投影文档)`

- 仅返回指定的字段和_id字段：通过投影文档完成，1为返回 0为过滤

  ```sh
  db.inventory.find( { status: "A" }, { item: 1, status: 1 } )
  ```

  将返回_id, item, status字段，注意默认会返回id，如果要禁用请指明id为0

- 返回除了被排除的字段之外的所有字段

  ```sh
  db.inventory.find( { status: "A" }, { status: 0, instock: 0 } )
  ```

- 返回嵌入式文档中的特定字段

  ```sh
  db.inventory.find(  { status: "A" },  { item: 1, status: 1, "size.uom": 1 } )
  ```

- 返回数组中的项目特定数组元素

  ```sh
  db.inventory.find( { status: "A" }, { item: 1, status: 1, instock: { $slice: -1 } } )
  ```

  提供了三个运算符: $elemMatch，$slice和$

### 查询数组

- 匹配一个数组
- 查询一个元素
- 多个条件查询元素
  - { "tags" : { $gt:10, $lt:15 } } 有一个元素大于10，另一个元素小于15
  - { "tags" : { $elemMatch : { $gt:10, $lt:15 } } }至少有一个元素在10-15之间
- 通过索引查询：{ "tags.1" : "a" }
- 通过长度查询：$size

### 查询null

```sh
db.inventory.insertMany([
  { _id: 1, item: null },
  { _id: 2 }
])
```

- 平等过滤器：db.inventory.find( { item: null } )
- 类型检查：db.inventory.find( { item : { $type: 10 } } )
- 存在检查：db.inventory.find( { item : { $exists: false } } )

### 嵌套查询

```sh
db.inventory.insertMany( [
   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "A" },
   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "A" },
   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },
   { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "D" },
   { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "A" }
]);
```

```sh
db.inventory.find( { "size.uom": "in" } )
#查找size下uom为in的文档

db.inventory.find( { "size.h": { $lt: 15 } } )
#查找size下h大于15的文档
```

# 22 学习强国计划

积分累计规则

(1)登录

(12)文章：进入文章页面至少5秒

(6)视频：至少10秒

(6)视频时长：1分/1分钟

(5)每日答题：需要文字识别

(10)专项答题

规则：

​	答案：查看提示=>> 识别红色文字

​	<img src="https://cdn.gincool.com//img/image-20211015114938140.png" alt="image-20211015114938140" style="zoom: 25%;" />

- 选择：

  ![image-20211015115028171](https://cdn.gincool.com//img/image-20211015115028171.png)

- 输入：

  <img src="https://cdn.gincool.com//img/image-20211015114855188.png" alt="image-20211015114855188" style="zoom:33%;" />

每日至少40分，每月30*40=1200

每日最大60分，每月最大60*30=1800

目标1000分，需时长：1000/40 = 25天

目标5000分，需时长：5000/40 = 125天

目标10000分，需时长：10000/40 = 250天

# ~~23 Node端的时间格式化工具库-format~~

:x: 没看懂

date-fns/format：https://github.com/date-fns/date-fns

date-fns/format文档地址：https://date-fns.org/

示例

```ts
import * as _dateFormat from 'date-fns/format';

export const dateFormat = (date = null, format = 'yyyy-MM-dd HH:mm:ss') => {
  if (date === null || date === undefined) {
    date = new Date(); // eslint-disable-line no-param-reassign
  }
  const t = date instanceof Date ? date : new Date(date);
  // @ts-ignore
  return _dateFormat(t, format);
};
```

# 24 docker启动mysql方法-docker创建mysql

### 第一步：拉取并运行镜像

```sh
docker image pull mysql:latest

# 如果是m1
docker pull mysql/mysql-server

docker run -d --restart=always --name nest-dashboard -p 3308:3306 -v /root/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=LOVEJJ@stung2 mysql:latest

# 如果是m1
docker run -d --restart=always --name my-mysql -p 3040:3306 -v /Users/jiangjin/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root mysql/mysql-server

#密码为root
#-v表示挂载目录
```

### 第二步：创建数据库

```sh
docker container exec -it nest-dashboard bash;
mysql -u root -p;
CREATE DATABASE  `nest-dashboard` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

CREATE DATABASE  `hap_vac` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
```

```mysql
ALTER USER 'root'@'%' IDENTIFIED BY 'root' PASSWORD EXPIRE NEVER;

ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root';
```



[1] Docker MySQL数据持久化.https://www.jianshu.com/p/351b71c3cd5a

### 数据备份

第一种：通过通过navcat应用导入导出数据

第二种：通过命令

```sh
#导出
mysqldump -u root -p nest-dashboard record > dump_record_2021-11-02_17:15:03.txt

#导入
mysql -u root -p database_name < dump.txt

#如果两台服务器互通
mysqldump -u root -p database_name \
       | mysql -h other-host.com database_name
```

[1] MySQL 导出数据.https://www.runoob.com/mysql/mysql-database-export.html

# 25 nestjs利用typeorm连接数据库

注意问题1：Error: RepositoryNotFoundError: No repository for [Enitity] was found. Looks like this entity is not registered in current "default" connection?

1.检查user.entity.ts是否带有 `@Entity()` 装饰器

2.检查app.module.ts中的连接方法 `TypeOrmModule.forRoot` 是否配置了entity

3.检查user.module.ts中的导入方法 `TypeOrmModule.forFeature` 是否导入了entity

### 第一步：安装依赖

```sh
yarn add @nestjs/typeorm typeorm mysql2
```

### 第二步：配置数据库，并连接

用docker创建数据库，详见【24 docker启动mysql方法】

之后，配置数据库连接

```ts
//app.module.ts
imports: [
  TypeOrmModule.forRoot({
    type: 'mysql',
    // host: 'localhost',
    host: '192.168.3.42',
    port: 3310,
    username: 'root',
    password: 'root',
    database: 'ginlink_test',
    entities: [User],
    charset: 'utf8mb4',
    timezone: '+08:00',
    synchronize: true,
  }),
  UserModule,
],
```

### 第三步：创建实体（entity），并配置、注入实体

- 配置到app.module => TypeOrmModule.forRoot，如上第二步
- 配置到user.module => TypeOrmModule.forFeature，如下
- 注入到user.service => constructor，如下
- 配置实体，如下

```ts
//user.module.ts
imports: [TypeOrmModule.forFeature([User])],
```

```ts
//user.service.ts
constructor(
  @InjectRepository(User)
  private usersRepository: Repository<User>,
) {}
```

```ts
//user.entity.ts
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  account: string;

  @Column()
  password: string;

  @Column({ default: true })
  isActive: boolean;
}
```

### 第四步：书写控制器和服务

```ts
//user.controller.ts
@Post('register')
async register(@Body() user: Partial<User>) {
  const newUser = await this.userService.createUser(user);
  return newUser;
}
```

```ts
//user.service.ts
async createUser(user: Partial<User>) {
  const { account, password } = user;

  if (!account || !password)
    throw new HttpException('请输入用户名或者密码', HttpStatus.BAD_REQUEST);

  const existUser = await this.usersRepository.findOne({
    where: { account },
  });

  if (existUser)
    throw new HttpException('用户名已存在', HttpStatus.BAD_REQUEST);

  const newUser = await this.usersRepository.create(user);
  await this.usersRepository.save(newUser);

  return newUser;
}
```

[1] nestjs连接数据库.https://docs.nestjs.cn/8/techniques?id=%e6%95%b0%e6%8d%ae%e5%ba%93

# 26 ts中的Partial、Pick、Omit、Required

```ts
interface User {
  name: string;
  age: number;
}
//[1]Partial<T>可以让T类型都变为可选的
const a: Partial<User> = {};
=> {name?: string; age?: number}

//[2]Pick<T, seleted>可以选择需要T类型中的哪一个或多个类型
const b: Pick<User, 'age'> = {};
=>> {age: number}

const b: Pick<User, 'age' | 'name'> = {};
=>> {name: string; age: number}

//[3]Omit<T, seleted>可以选择忽略T类型中的哪一个或多个类型
const b: Omit<User, 'age'> = {};
=>> {name: string}
```

[1] TypeScript Utility Types Part 1: Partial, Pick, and Omit.https://www.dslemay.com/blog/2020/04/27/typescript-utility-types-part-1-partial-pick-and-omit

这篇文档中还有其他好的Ts类型文章，例如：

- Part 1: Partial, Pick, and Omit
- Part 2: Record, Readonly, & Required
- Part 3: Extract, Exclude, and NonNullable

### Required

```ts
interface User {
  name: string;
  age: number;
  height?: string;
}

//Required与Partial正好相反，要求所有参数为必须参数
const c: Required<User> = {}
=>> {  name: string; age: number; height: string; }
```

# 28 ts中的装饰器

装饰器是一项ECMA提案，只是在ts中先实现了。

### 问题一：ts中的装饰器与js中的装饰器有什么区别？

> TODO

### 问题二：装饰器的种类？

在typescript中一共有五类。类、属性、方法、访问器、参数。

修饰类

```ts
type ClassDecorator = <TFunction extends Function>
  (target: TFunction) => TFunction | void;

//target: 类的构造器。
```

修饰属性

```ts
type PropertyDecorator =
  (target: Object, propertyKey: string | symbol) => void;

//target: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。
//propertyKey: 属性的名称。
```

修饰方法

```ts
type MethodDecorator = <T>(
  target: Object,
  propertyKey: string | symbol,
  descriptor: TypedPropertyDescriptor<T>
) => TypedPropertyDescriptor<T> | void;

//target: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。
//propertyKey: 属性的名称。
//descriptor: 属性的描述器。
```

修饰访问器：类似于修饰方法，区别在于descriptor([属性描述符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty))，方法是数据描述符，而访问器是存取描述符

修饰参数

```ts
type ParameterDecorator = (
  target: Object,
  propertyKey: string | symbol,
  parameterIndex: number
) => void;

//target: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。
//propertyKey: 属性的名称(注意是方法的名称，而不是参数的名称)。
//parameterIndex: 参数在方法中所处的位置的下标。
```

### 问题三：装饰器的执行顺序？

属性参数方法-> 访问器-> 静态属性参数方法

-> 类

[1] TypeScript装饰器完全指南.https://saul-mirone.github.io/zh-hans/a-complete-guide-to-typescript-decorator/

### 问题四：typescript的tsconfig.json中的 `module` 配置项与项目有什么关系？

没有太大关系，module可以配置为esm

一般后端项目，module为commonjs，因为大多数包都还是commonjs的，而esmodule是兼容commonjs的，所有module选项一般设置未commonjs

只是要注意一个问题，ts2.7的配置中出了一个esModuleInterop的配置，可以解决esmodule中impot只导入default属性的问题

```ts
import d from "cjs"

//以前写法
import * as d from "cjs"
```

[1] typescript中的模块引用.https://segmentfault.com/a/1190000019793220

### 问题五：Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option `to remove this warning.

:x: [stackoverflow](https://stackoverflow.com/questions/38271273/experimental-decorators-warning-in-typescript-compilation)上有相关问题，但it not work

介绍：利用tsc编译typescript文件的时候出现上述错误，但我在tsconfig.json中已经配置了 `experimentalDecorators` 属性，未生效？

:white_check_mark: 原因：tsc命令为全局的命令，在默认tsc工作路径，是没有配置文件的，所以需要让它感知tsconfig.json的存在，在package.json创建命令，此时tsc的工作路径就是当前

```json
//package.json
"scripts": {
  "dev": "tsc -w"
}
```

# 29 ECMA

介绍：[Ecma](https://www.ecma-international.org/about-ecma/) 为信息和通信行业制定和发布国际标准。自 1961 年至今，Ecma International 一直在全力推动及时创建广泛的全球信息和通信技术 (ICT) 和消费电子 (CE) 标准。

### ECMA-262

[ECMA-262](https://www.ecma-international.org/publications-and-standards/standards/ecma-262/) 指的是 `ECMAScript 通用编程语言规范`，它属于TC39技术委员会管理的项目。

截止2020.6，已经发行到第11版，完整的版本见https://www.ecma-international.org/publications-and-standards/standards/ecma-262/

# 30 TypeORM

问题一：数据库相关知识要掌握到什么程度？

问题二：不用创建表啦？是的，typeorm自动创建表，应用程序中的模型即是数据库中的表。

### 问题三：什么是左连接、内连接？

连接都是针对于两个表的

- left join （左连接）：返回包括左表中的所有记录和右表中 `连接字段` 相等的记录。
- right join （右连接）：返回包括右表中的所有记录和左表中 `连接字段` 相等的记录。
- inner join （等值连接或者叫内连接）：只返回两个表中 `连接字段` 相等的行。
- full join （全外连接）：返回左右表中所有的记录和左右表中 `连接字段` 相等的记录。

### 问题四：什么是having？

having类似where，where用于分组前，having用于分组后。原因在于where关键字无法与合计函数一起使用，所以才创建having关键字。

```sql
SELECT Customer,SUM(OrderPrice) FROM Orders
GROUP BY Customer
HAVING SUM(OrderPrice)<2000
```

| O_Id | OrderDate  | OrderPrice | Customer |
| :--- | :--------- | :--------- | :------- |
| 1    | 2008/12/29 | 1000       | Bush     |
| 2    | 2008/11/23 | 1600       | Carter   |
| 3    | 2008/10/05 | 700        | Bush     |
| 4    | 2008/09/28 | 300        | Bush     |
| 5    | 2008/08/06 | 2000       | Adams    |
| 6    | 2008/07/21 | 100        | Carter   |

查询结果

| Customer | SUM(OrderPrice) |
| :------- | :-------------- |
| Carter   | 1700            |

[1] SQL Having的用法.https://blog.csdn.net/u014401141/article/details/53010608

### 问题五：sql查询中都有哪些概念？

- [x] where条件查询

  ```ts
  createQueryBuilder("user").where("user.name = :name", { name: "Timber" });
  ```

- [x] having条件查询

  ```ts
  createQueryBuilder("user").having("user.name = :name", { name: "Timber" });
  ```

- [ ] order by排序查询

  ```ts
  createQueryBuilder("user").orderBy("user.id", "DESC");
  
  createQueryBuilder("user").orderBy("user.id", "ASC");
  ```

- [ ] group by分组查询

  ```ts
  createQueryBuilder("user").groupBy("user.id");
  ```

- [ ] limit

  ```ts
  createQueryBuilder("user").limit(10);
  ```

  注意：如果你使用带有连接或子查询的复杂查询，LIMIT 可能无法正常工作。 如果使用分页，建议使用`take`代替。

- [ ] offset

  ```ts
  createQueryBuilder("user").offset(10);
  ```

  注意：如果你使用带有连接或子查询的复杂查询，OFFSET 可能无法正常工作。 如果使用分页，建议使用`skip`代替。

- [ ] 联查

  

- [ ] 内联和左联

- [ ] 分页

- [ ] 加锁

- [ ] 子查询



