---
sidebar_position: 1
title: 11-3
tags:
  - 日常记录
---



# 1 在线设计表结构-ER模型

[1] https://dbdiagram.io/d/61820170d5d522682df60058

# 2 Crontab基础使用

见 **24点**

# 3 一定要注意Nestjs的守卫、策略都需要@Injectable()修饰符

如果不加修饰符，那么内部无法使用其他注入对象，因为没有上下文

```ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { User } from '../user/user.entity';
import { AuthService } from './auth.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private readonly authService: AuthService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: 'ginlink',
    });
  }

  async validate(payload: User) {
    console.log('[JwtStrategy](payload):', payload);
    
    //如果不加注入，那么authService永远为undefined
    console.log('[JwtStrategy](authService):', this.authService);
    const user = await this.authService.validateUser(payload);

    console.log('[JwtStrategy](user):', user);
    if (!user) {
      console.log('[JwtStrategy](身份验证失败):');
      throw new UnauthorizedException('身份验证失败');
    }

    return user;
  }
}
```

# 4 Nestjs中微信登录+JWT+token鉴权流程

一共分为三步：1微信登录；2生成token；3JWT鉴权

### 第一步：微信登录

首先，看一下微信开放平台的登录流程图，大体分为两步：

- 客户端通过 `wx.login` 获取code，之后将code扔给服务器
- 服务端拿到code去微信服务器获取 `session_key` 和 `openid`，结束。

这里最重要的就是openid，它是用户的唯一标识，不会改变。session_key中保存着用户的信息（一些头像和昵称，省份等等）基本没什么用。

![img](https://res.wx.qq.com/wxdoc/dist/assets/img/api-login.2fcc9f35.jpg)

### 第二步：生成token

生成token很简单，利用jwt的sign方法即可：

```ts
const token = this.jwtService.sign({
  id: user.id,
  open_id: user.open_id,
  session_key: user.session_key,
  nick_name: user.nick_name,
  avatar_url: user.avatar_url,
});
//sign就是一系列加密算法，其中包含了自己的 盐（密匙）
//sign的内容需要解密才能看到
```

如何解密？利用jwt的decode方法即可：

```ts
const user = this.jwtService.decode(token) as User;
//user就是加密前的数据
```

### 第三步：鉴权流程

鉴权流程不难，分为两步：

- 首先，得有一个鉴权策略，策略中进行身份验证

- 之后，在authModule中注册策略和JWT

```ts
//jwt.strategy.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { User } from '../user/user.entity';
import { AuthService } from './auth.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private readonly authService: AuthService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: 'ginlink', //这里放自己的盐
    });
  }

  //验证规则
  async validate(payload: User) {
    const user = await this.authService.validateUser(payload);

    if (!user) {
      console.log('[JwtStrategy](身份验证失败):');
      throw new UnauthorizedException('身份验证失败');
    }

    return user;
  }
}
```

```ts
//auth.module.ts
import { forwardRef, Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { UserModule } from '../user/user.module';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './jwt.strategy';

//注册策略，选择默认策略为JwtStrategy
const passModule = PassportModule.register({ defaultStrategy: 'jwt' });
//配置jwt
const jwtModule = JwtModule.register({
  secret: 'ginlink', //自己的盐
  signOptions: { expiresIn: '4h' },
});

@Module({
  imports: [passModule, jwtModule, forwardRef(() => UserModule)],
  providers: [AuthService, JwtStrategy],
  controllers: [AuthController],
  exports: [passModule, jwtModule],
})
export class AuthModule {}
```

为了使用方便，将鉴权写成守卫的形式

```ts
//jwt-auth.guard.ts
import {
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  getRequest(context: ExecutionContext) {
    const ctx = context.switchToHttp();
    const request = ctx.getRequest();
    return request;
  }

  handleRequest<User>(err, user: User): User {
    if (err || !user) {
      throw new UnauthorizedException('身份验证失败');
    }

    return user;
  }
}
```

使用

```ts
//通过守卫的方式使用
@Get()
@UseGuards(JwtAuthGuard)
@HttpCode(HttpStatus.OK)
async findByOpenId(@Request() req) {
  //这里去解密token中的数据
  let token = req.headers.authorization;

  if (/Bearer/.test(token)) {
    // 不需要 Bearer，否则验证失败
    token = token.split(' ').pop();
  }
  const user = this.jwtService.decode(token) as User;
  
  //拿到token中的数据后，进行其他逻辑
  const foundVacation = await this.vacationService.findOneRandomVacation();

  const d = await this.userService.findAndMock(user, foundVacation);
  return Object.assign(d, { token });
}
```

# 5 Column type for UserModel#userId is not defined and cannot be guessed. Make sure you have turned on an "emitDecoratorMetadata": true option in tsconfig.json.

@ManyToOne不要与@Column连用

```ts
//错误示范
@ManyToOne((type) => User, (user) => user.vacations)
@Column()
user: User;

//正确
@ManyToOne((type) => User, (user) => user.vacations)
user: User;
```

# 6 What is the difference between a transaction and a call?

问题一：交易和call调用有什么区别？

问题二：只读方法不需要gas费吗？

> TODO

[1] Calls vs. transactions in Ethereum smart contracts.https://blog.b9lab.com/calls-vs-transactions-in-ethereum-smart-contracts-62d6b17d0bc2

# 7 token-tmp

```
2021-11-08 14:57:30
token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwib3Blbl9pZCI6Im9SSTVrNWVTamxSTWNyN3hPTnc5eFptU3VGeDgiLCJzZXNzaW9uX2tleSI6InRpR2JBT3ZWYU8rVU9sTGtLTkVmUEE9PSIsIm5pY2tfbmFtZSI6IuWIh-aNouWIsOWkp-WktCIsImF2YXRhcl91cmwiOiJodHRwczovL3RoaXJkd3gucWxvZ28uY24vbW1vcGVuL3ZpXzMyL1EwajRUd0dUZlRLbHB1WHoxNDZVOFFMa0ZxUmdOdGJjcjNDa0dkSXVrMHluWUdQajBIS0pVQkJDbVN2ODhpY28ySkg1Z0c2ZHlhZDJWWm9ZaWFiamliVjFnLzEzMiIsImlhdCI6MTYzNjM1NDYxNywiZXhwIjoxNjM2MzY5MDE3fQ.7pNE8katO3yNgD9PIffWjChAII4lcnMRNRz91a7EbBU"
```

# 8 关于Nestjs循环引用（导入）问题

问题一：有些service中无法导入另一个service，但在controller中可以导入，为什么？

# 9 幸运请假中的幸运如何体现？

通过 `幸运转转转` 抽取奖励，奖励分为：

| 奖励类型 | 奖励（天数） | 概率分配 |
| -------- | ------------ | -------- |
| 一等奖   | + 3          | 1        |
| 二等奖   | + 1          | 4        |
| 三等奖   | 0            | 7        |
| 四等奖   | -1           | 4        |
| 特等奖   | -3           | 1        |

说明：1.奖励进行累加制，可以无限大，也可以无限小；2.每天用户可免费抽取一次；

计划：通过原有积分去转，每次需天数为1。

### 实现

所需字段：

| 字段名称 | 字段英文   |
| -------- | ---------- |
| 所剩天数 | left_times |

### 概率

总共17份，最低概率5.88%，最高概率41.17%

概率调整为 xx 份，最低概率为2%左右，最高概率为50%左右

# 10 Mockjs随机手机号

```ts
const Mock = require('mockjs')
// 拓展mockjs
Mock.Random.extend({
     
  phone: function () {
     
    var phonePrefixs = ['132', '135', '189'] // 自己写前缀哈
    return this.pick(phonePrefixs) + Mock.mock(/\d{8}/) //Number()
  }
})

console.log(Mock.Random.phone())
```

[1] 使用mockjs生成随机手机号码.https://www.it610.com/article/1305163360731435008.htm

### 附：随机生成一个中文名字

```ts
Random.cname()
```

# 11 关于Mysql中的timestamp

注意：timestamp表示时间戳，它有很多种形式，它并不代表 `unix时间戳` （例如：1636303506）

**时间戳记**或称为**时间标记**（英语：timestamp）是指字符串或编码信息用于识别记录下来的时间日期。国际标准为[ISO 8601](https://zh.wikipedia.org/wiki/ISO_8601)。

时间戳记的示例如下：

- 2016-12-25T00:15:22Z
- 2005-10-30 10:45 [UTC](https://zh.wikipedia.org/wiki/UTC)
- Sat Jul 23 02:16:57 2005
- 2016年12月25日 (日) 00:14 (UTC)

[1] UNIX时间.https://zh.wikipedia.org/wiki/UNIX%E6%97%B6%E9%97%B4

[2] 时间戳.https://zh.wikipedia.org/wiki/%E6%99%82%E9%96%93%E6%88%B3

### 附：dayjs解析 & 格式化为unix时间戳的方法

```ts
//解析毫秒|秒
dayjs(1318781876406) //注意为number类型
dayjs.unix(1318781876)
//或者也可以这样
dayjs(1318781876 * 1000)

//格式化毫秒|秒
dayjs('2019-01-25').valueOf()
dayjs('2019-01-25').unix()
=>
	1548381600000
	1548381600
```

[1] Day.js.https://dayjs.gitee.io/zh-CN/

# 12 Cannot find module 'babel-plugin-babel-react-rif'

背景：在使用 `lingui extract --locale en-US` 生成翻译文件时，报错

原因：babel-plugin-babel-react-rif与lingu命令不兼容，这些babel与很多都不兼容（例如：jest），建议不要使用

解决方案：检查你的 `.babelrc` ，如果如下，请先将babelrc改名（或者直接删除这些插件）

```json
{
  "plugins": [
    "babel-react-rif",
    "babel-react-rfor",
    "babel-react-rmodel",
    "babel-react-rshow"
  ]
}
```

### 附：can not find module 'babel-plugin-import'

原因：`react-app-rewired` 需要babel插件支持

解决方案：请安装这两个包

```json
"@babel/core": "^7.4.5",
"babel-plugin-import": "^1.13.0",
```

# 13 总结使用 `lingui` 国际化流程

lingui国际化是lingui在i18n的基础上的一个工具，i18n负责运行时，lingui则负责开发期间。lingui让翻译变得更加轻松。

整体来说，最主要配置就两个地方，`lingui.config.ts` 和 `i18n.ts`

- lingui为 `开发时依赖` ，主要配置工具运行期间的一些配置，如：工作路径，输入源，输出的格式等等

- i18n为 `运行时依赖` ，配置大家都熟悉，如：切换语言，支持的语言等

```ts
//lingui.config.ts
export default {
  catalogs: [
    {
      path: '<rootDir>/src/locales/{locale}',
      include: ['<rootDir>/src'],
    },
  ],
  compileNamespace: 'cjs',
  fallbackLocales: {
    default: 'en-US',
  },
  format: 'po',
  formatOptions: {
    lineNumbers: false,
  },
  locales: [
    'en-US',
    'zh-CN',
  ],
  orderBy: 'messageId',
  rootDir: '.',
  runtimeConfigModule: ['@lingui/core', 'i18n'],
  sourceLocale: 'en-US',
}
```

```ts
import React, { useEffect, useState } from 'react'
import { i18n } from '@lingui/core'
import { I18nProvider } from '@lingui/react'
import { ReactNode } from 'react'
import { useActiveLocale, useSetLocaleFromUrl } from 'hooks/useActiveLocale'
import { SupportedLocale } from 'constants/locales'
import {
  en,
  zh,
  PluralCategory,
} from 'make-plural/plurals'
//https://www.npmjs.com/package/make-plural

type LocalePlural = {
  [key in SupportedLocale]: (n: number | string, ord?: boolean) => PluralCategory
}

const plurals: LocalePlural = {
  'en-US': en,
  'zh-CN': zh,
}

//动态加载.po文件，并切换到相应语言
export async function dynamicActivate(locale: SupportedLocale) {
  const { messages } = await import(`@lingui/loader!./locales/${locale}.po`)
  i18n.loadLocaleData(locale, { plurals: () => plurals[locale] })
  i18n.load(locale, messages)
  i18n.activate(locale)
}

export function LanguageProvider({ children }: { children: ReactNode }) {
  useSetLocaleFromUrl()
  const locale = useActiveLocale()
  const [loaded, setLoaded] = useState(false)

  useEffect(() => {
    dynamicActivate(locale)
      .then(() => {
        setLoaded(true)
      })
      .catch((error) => {
        console.error('Failed to activate locale', locale, error)
      })
  }, [locale])

  // prevent the app from rendering with placeholder text before the locale is loaded
  if (!loaded) return null

  return (
    <I18nProvider forceRenderOnLocaleChange={false} i18n={i18n}>
      {children}
    </I18nProvider>
  )
}
```

# 14 Mysql报错：ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client

原因： This is because `caching_sha2_password` is introduced in MySQL 8.0, but the Node.js version is not implemented yet.（Mysql8中引入了caching_sha2_password模式，但nodejs中还不支持）

:white_check_mark: 解决方案：

```sh
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password';
#如果不行，将@'localhost'去掉，即
ALTER USER 'root' IDENTIFIED WITH mysql_native_password BY 'password';

#之后再刷新一下
flush privileges;
```

注意：root为数据库 `用户名` ，password为 `密码`

[1] MySQL 8.0 - Client does not support authentication protocol requested by server; consider upgrading MySQL client.https://stackoverflow.com/questions/50093144/mysql-8-0-client-does-not-support-authentication-protocol-requested-by-server?page=1&tab=votes#tab-top

# 15 请求数据中的几种状态

最基础有三种状态，loading，complete，error（请求中，请求完成，请求出错）

```ts
export enum State {
  LOADING,
  INVALID,
  NO_ROUTE_FOUND,
  VALID,
  SYNCING,
}
//枚举类型默认从0开始
```

# 16 Vue实现的幸运大转盘

项目地址见 **[1]**

<img src="https://cdn.gincool.com//img/image-20211109210711427.png" alt="image-20211109210711427" style="zoom:33%;" />

### 附：如何修改转盘？

转盘用sketch的 `钢笔` 工具进行绘制即可

[1] landluck/lucky_wheel.https://github.com/landluck/lucky_wheel

# 17 Brew如何使用？

### 第一步：切换源

[1] Mac 下 brew 切换为国内源.https://cloud.tencent.com/developer/article/1614039

### 第二步：使用brew安装软件即可

```sh
brew install wget

brew uninstall wget

#查看已安装包列表
brew list

#更新
brew update
```

### 附：安装brew

```sh
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
```

# 18 子网掩码

**IP地址**：192.168.1.129，**子网掩码**：255.255.255.0

计算：

```text
1100 0000.1010 1000.0000 0001.1000 0001
1111 1111.1111 1111.1111 1111.0000 0000
————————————————————
1100 0000.1010 1000.0000 0001.0000 0000
```

用 `乘法` 来遮掩IP地址。1×1=1、1×0=0、0×0=0、0×1=0

计算后的这段二进制代码相比于原来的IP地址，后面8位被用0遮掩了。

```text
1100 0000.1010 1000.0000 0001.0000 0000
1100 0000.1010 1000.0000 0001.1111 1111
```

即192.168.1.0到192.168.1.255或者192.168.1.0/24

### 再来看一个

**新IP地址**：192.168.1.188 再给出**新的子网掩码**：255.255.255.224

```
1100 0000.1010 1000.0000 0001.1011 1100  
1111 1111.1111 1111.1111 1111.1110 0000  
————————————————————
1100 0000.1010 1000.0000 0001.1010 0000
```

后5位被遮掩了

```
1100 0000.1010 1000.0000 0001.1010 0000
1100 0000.1010 1000.0000 0001.1011 1111
```

即192.168.1.160到192.168.1.191或者192.168.1.160/27

### 10.0.0.0/8什么意思？

/8表示有8位未被遮掩，/24就表示有24位未被遮掩

# 19 15服务器开放端口

```
tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:9010            0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:7802            0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:9020            0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:9701            0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:9990            0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:9902            0.0.0.0:*               LISTEN      -  
```

已使用

```
0.0.0.0:9902->9902/tcp
0.0.0.0:9020->80/tcp
0.0.0.0:9701->9901/tcp
0.0.0.0:8080->80/tcp
0.0.0.0:9990->80/tcp
0.0.0.0:9010->9991/tcp
0.0.0.0:7802->7802/tcp
0.0.0.0:3306->3306/tcp
```

# 20 如何扫描端口

### 本机：用netstat

```sh
netstat -lntup
```

### 远端：用nmap

```sh
nmap -sS -p20-100 ip -vv

-sS是向远程主机端口发送syn包，根据回包判断端口是否开放，这种扫描有很大的误报，因为没有建立tcp三次握手，扫描会比较快
-sT是全连接扫描，会与对方建立三次握手，扫描结果比较准确，但是比较慢
-p指定端口，-p-表示扫描整个端口（0-65535）
-vv显示详细信息
```

# 22 做一个交易所

图表：TradingView.https://www.tradingview.com/chart/![image-20211111055626301](https://cdn.gincool.com//img/image-20211111055626301.png)

# 23 Nextjs的一些概念

总体来讲，nextjs就是客户端、预渲染和服务器渲染的集合体，通过编码可以决定以什么样的方式进行渲染网页。（client-side render，pre-render，server-side render）

一般：`后台` 一类用react搭建即可；`官网` 一类用预渲染；`博客` 一类用服务器渲染；

注意：渲染系统可以交错，例如：一个博客项目，它内部用到服务器渲染（一片片博文），也会用到客户端渲染（用户信息），也可能会用到预渲染（首页，或者一些固定的内容）

# 24 利用Crontab定时任务向数据库写入数据

重点：1.crontab任务格式；2.登录mysql；

### 第一：Crontab任务格式

```sh
基本格式 :
*　　*　　*　　*　　*　　command
分　时　日　月　周　命令
```

例如：

```sh
#每分钟执行一次，例如：00:01, 00:02, 00:03
*/1 * * * * /root/crontab/task_minutes/minute.sh

#每年、每月、每天、每小时的1分钟执行一次，例如：00:01, 01:01, 02:01
1 * * * * /root/crontab/task_minutes/minute.sh
```

`*/1` 表示每1分钟，注意上面两个的区别

> :warning: 注意：crontab的默认执行路径为，`当前用户的根路径。`所以一般编写自动化脚本的时候，经常会先cd到具体路径去，例如：

```sh
#!/bin/bash

cd /root/crontab/task_minutes

echo 'hello' >> ./b.txt
```

附：crontab的一些命令

```sh
sudo service crond start     #启动服务
sudo service crond stop      #关闭服务
sudo service crond restart   #重启服务
sudo service crond reload    #重新载入配置
sudo service crond status    #查看服务状态
```

[1] Linux Crontab命令定时任务基本语法.https://www.cnblogs.com/dalianpai/p/11813950.html

### 第二：登录mysql

```sh
#mysql -h 172.33.101.123 -P 3306 -u tony -pYourPassword -D YourDbName << EOF
mysql -h 127.0.0.1 -P 3306 -u root -p $MYSQL_PASSWARD -D databaseName << EOF
select current_date();
use tony_db;
desc confirmed_order_data;
select count(*) from confirmed_order_data where paid_date<="$wanted_date";
delete from confirmed_order_data WHERE paid_date<="$wanted_date";
select count(*) from confirmed_order_data where paid_date<="$wanted_date";

EOF
```

:warning: 注意：1这些带 `$` 符号的要配置为环境变量；2-P和-h是连用的，不能只单独出现-P

示例：更新id为1的数据

```sql
UPDATE runoob_tbl SET runoob_title='学习 C++' WHERE runoob_id=3;
```

### 实例：crontab自动更新数据库

两步：1设置crontab任务；2书写执行的脚本

```sh
#进入定时任务创建界面
crontab -e
```

```sh
SHELL=/bin/bash

# hap_vac_mysql
*/1 * * * * /root/crontab/task_hap-vac/daily.sh >> $HOME/crontab/task_hap-vac/mylog.log 2>&1
```

执行的脚本

```sh
#daily.sh

#!/bin/bash
#设置环境变量
source $HOME/.bash_profile2

echo "db user is $DB_USER"

#下面是登录mysql和执行sql语句
mysql -h $DB_HOST -P $DB_PORT -u $DB_USER -p$DB_PASSWD << EOF
use hap_vac;
update user set is_login=0,free_coin=0;
EOF

current_time=$(date "+%Y-%m-%d %H:%M:%S")
echo "update daily hap_vac at $current_time"
```

:warning: 注意：crontab的指定是不知道环境变量的，所以要source一下环境变量，详细见**[2]**



[1] 在shell脚本中登录Mysql并执行SQL语句.https://blog.csdn.net/qq_31598113/article/details/79887960

[2] 如何使用现有环境变量运行cron命令？.https://qastack.cn/unix/27289/how-can-i-run-a-cron-command-with-existing-environmental-variables

[3] 如何查看crontab的日志记录.https://blog.51cto.com/461205160/1736383

# 25 如何发布npm公共包

> TODO

# 26 @ant-design/icons动态加载

antd的图标库升级到了4之后，无法通过指定字符串加载对应图标了，如何解决呢？

以前这么写：

```tsx
<Icon type={'phone'} />
```

现在这么写：

```tsx
<StepForwardOutlined />
```

思路：将需要的图标导出

```tsx
import { DashboardOutlined, UserOutlined } from '@ant-design/icons'
import { createElement } from 'react'

//导入需要的图标
const Icons = {
  DashboardOutlined,
  UserOutlined,
} as {
  [key: string]: any
}

//传入需要的图标名称，例如：'UserOutlined'
export default function AntdIcon(iconString: string) {
  const Icon = Icons[iconString] ? createElement(Icons[iconString]) : null

  if (!Icon) {
    console.debug('[AntdIcon](未加载到图片):', iconString)
  }

  return Icon
}
```

# 27 注意react中return语句

```tsx
//正确写法
export default function Icon(){
  return SomeIcon
  return <>{ SomeIcon }</>
}

//错误示范
export default function Icon(){
  return { SomeIcon }
}
```

后者会报错，因为返回值为类

# 28 Nestjs搜索案例

> TODO

